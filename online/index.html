<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>NONAGA „Ç™„É≥„É©„Ç§„É≥ÂØæÊà¶ - ÂÖ≠ËßíÂΩ¢„Éú„Éº„Éâ„Ç≤„Éº„É†</title>
  <meta name="description" content="NONAGA„Ç™„É≥„É©„Ç§„É≥ÂØæÊà¶„É¢„Éº„Éâ„ÄÇÂèãÈÅî„Å®„É™„Ç¢„É´„Çø„Ç§„É†„ÅßÂØæÊà¶„Åó„Çà„ÅÜ„ÄÇURL„ÇíÂÖ±Êúâ„Åô„Çã„Å†„Åë„ÅßÁ∞°Âçò„Å´ÂØæÊà¶ÈñãÂßãÔºÅ">

  <!-- Open Graph -->
  <meta property="og:title" content="NONAGA „Ç™„É≥„É©„Ç§„É≥ÂØæÊà¶">
  <meta property="og:description" content="ÂèãÈÅî„Å®„É™„Ç¢„É´„Çø„Ç§„É†„ÅßÂØæÊà¶„Åó„Çà„ÅÜ">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://nonaga.riverapp.jp/online/">
  <meta property="og:image" content="https://nonaga.riverapp.jp/public/og-image.png">
  <meta property="og:locale" content="ja_JP">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="NONAGA „Ç™„É≥„É©„Ç§„É≥ÂØæÊà¶">
  <meta name="twitter:description" content="ÂèãÈÅî„Å®„É™„Ç¢„É´„Çø„Ç§„É†„ÅßÂØæÊà¶„Åó„Çà„ÅÜ">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/public/favicon.png">
  <link rel="apple-touch-icon" href="/public/apple-touch-icon.png">

  <!-- Canonical -->
  <link rel="canonical" href="https://nonaga.riverapp.jp/online/">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      -webkit-tap-highlight-color: transparent;
      background-color: #f8fafc;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      min-height: 100dvh;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    #root { display: flex; flex-direction: column; min-height: 100%; flex: 1; }
    .game-container {
      display: flex;
      flex-direction: column;
      flex: 1;
      transition: background-color 1s ease;
      width: 100%;
      position: relative;
    }
    .game-container.bg-rose { background-color: #fff1f2; }
    .game-container.bg-indigo { background-color: #eef2ff; }
    .game-container.bg-slate { background-color: #f8fafc; }
    .header { position: fixed; top: 0; left: 0; right: 0; padding: 0.5rem 1rem; padding-top: calc(0.5rem + env(safe-area-inset-top)); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; pointer-events: none; }
    .game-title { font-size: 1.1rem; font-weight: 900; color: #1e293b; font-style: italic; text-transform: uppercase; letter-spacing: 0.3em; }
    .status-container { position: fixed; top: 3rem; left: 0; right: 0; display: flex; flex-direction: column; align-items: center; padding: 0 1rem; width: 100%; z-index: 10; pointer-events: none; }
    .status-container > * { pointer-events: auto; }
    .victory-container { display: flex; flex-direction: column; align-items: center; z-index: 50; animation: slideInUp 0.6s cubic-bezier(0.17, 0.89, 0.32, 1.49) forwards; }
    .victory-badge { padding: 0.75rem 2rem; border-radius: 9999px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); border: 4px solid white; color: white; }
    .victory-badge.red { background-color: #f43f5e; }
    .victory-badge.blue { background-color: #6366f1; }
    .reset-button { margin-top: 0.75rem; padding: 0.5rem 1.5rem; background-color: #1e293b; color: white; border-radius: 9999px; font-size: 0.75rem; font-weight: 700; border: none; cursor: pointer; transition: all 0.2s; }
    .turn-indicator { background-color: rgba(255, 255, 255, 0.95); padding: 0.5rem 1.5rem; border-radius: 9999px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); border: 1px solid #f1f5f9; display: flex; align-items: center; gap: 1rem; transition: all 0.2s; }
    .turn-indicator.disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(0.3); pointer-events: none; }
    .player-indicator { display: flex; align-items: center; gap: 0.5rem; opacity: 0.3; transition: all 0.3s ease; }
    .player-indicator.active { opacity: 1; font-weight: 700; transform: scale(1.1); }
    .player-dot { width: 0.8rem; height: 0.8rem; border-radius: 50%; }
    .player-dot.red { background-color: #f43f5e; }
    .player-dot.blue { background-color: #6366f1; }
    .board-container { flex: 1; display: flex; align-items: center; justify-content: center; padding: 1rem 0.5rem 2rem; touch-action: none; min-height: 0; overflow: visible; }
    .board-svg { width: 100%; height: auto; max-height: 70vh; overflow: visible; filter: drop-shadow(0 10px 15px rgba(0,0,0,0.1)); }
    .tile { transition: all 0.8s ease; fill: white; stroke: #e2e8f0; stroke-width: 1px; }
    .tile.selected-origin { fill: #fee2e2; stroke: #f43f5e; stroke-width: 2px; }
    .tile.destination-hint { fill: #f0fdf4; stroke: #34d399; stroke-dasharray: 2; }
    .tile.selectable-empty { fill: white; stroke: #fbbf24; stroke-width: 2px; animation: tile-glow 2s ease-in-out infinite; }
    .tile.victory-tile { fill: #fff1f2; stroke: #fda4af; stroke-width: 4px; }
    .tile.victory-tile.blue { fill: #eef2ff; stroke: #a5b4fc; }
    .tile.faded { opacity: 0.2; }
    .piece-main { transition: all 0.3s ease; stroke: rgba(0,0,0,0.1); stroke-width: 1px; }
    .piece-main.red { fill: #f43f5e; }
    .piece-main.blue { fill: #6366f1; }
    .piece-main.selected { stroke: #fbbf24; stroke-width: 8px; animation: selected-pulse 0.6s ease-in-out infinite; }
    .piece-main.victory-piece { animation: piece-pulse 1.2s ease-in-out infinite; }
    .piece-main.my-turn { stroke: #fbbf24; stroke-width: 2px; animation: tile-glow 2s ease-in-out infinite; }
    @keyframes piece-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
    @keyframes tile-glow { 0%, 100% { stroke-width: 2px; } 50% { stroke-width: 3px; } }
    @keyframes selected-pulse { 0%, 100% { transform: scale(1.35); stroke-width: 8px; } 50% { transform: scale(1.5); stroke-width: 10px; } }
    @keyframes slideInUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    @keyframes spin { to { transform: rotate(360deg); } }
    .rules-container { position: fixed; bottom: 0; left: 0; right: 0; padding: 0 1rem 1.5rem; padding-bottom: calc(1.5rem + env(safe-area-inset-bottom)); width: 100%; max-width: 32rem; margin: 0 auto; pointer-events: none; z-index: 10; }
    .rules-card { background: white; padding: 0.6rem; border-radius: 0.75rem; border: 1px solid #f1f5f9; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05); display: flex; flex-direction: column; gap: 0.4rem; pointer-events: auto; }
    .goal-box { background: #fffbeb; padding: 0.75rem; border-radius: 0.75rem; display: flex; gap: 0.5rem; align-items: center; font-size: 0.8rem; color: #78350f; border: 1px solid #fde68a; cursor: pointer; }
    .goal-hint { font-size: 0.7rem; color: #92400e; opacity: 0.85; }
    .steps-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; }
    .step-item { display: flex; gap: 0.5rem; align-items: center; color: #64748b; font-size: 0.7rem; }
    .step-number { width: 1.35rem; height: 1.35rem; border-radius: 50%; background-color: #1e293b; color: white; display: flex; align-items: center; justify-content: center; font-weight: 700; flex-shrink: 0; }
    .lobby-container { display: flex; flex-direction: column; align-items: center; justify-content: center; flex: 1; padding: 20px; }
    .lobby-card { background: white; border-radius: 16px; padding: 32px; box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1); max-width: 400px; width: 100%; text-align: center; }
    .create-game-button { width: 100%; padding: 16px 24px; font-size: 18px; font-weight: 700; color: white; background: linear-gradient(135deg, #6366f1, #8b5cf6); border: none; border-radius: 12px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
    .create-game-button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99, 102, 241, 0.4); }
    .create-game-button:disabled { opacity: 0.6; cursor: not-allowed; }
    .error-message { color: #ef4444; margin-top: 16px; font-size: 14px; }
    .divider { display: flex; align-items: center; margin: 24px 0; }
    .divider::before, .divider::after { content: ''; flex: 1; height: 1px; background: #e2e8f0; }
    .divider span { padding: 0 16px; color: #94a3b8; font-size: 14px; }
    .local-game-link { color: #6366f1; text-decoration: none; font-weight: 500; }
    .local-game-link:hover { text-decoration: underline; }
    .loading-container { display: flex; flex-direction: column; align-items: center; justify-content: center; flex: 1; gap: 16px; color: #64748b; }
    .loading-spinner { width: 48px; height: 48px; border: 4px solid #e2e8f0; border-top-color: #6366f1; border-radius: 50%; animation: spin 1s linear infinite; }
    .waiting-container { display: flex; flex-direction: column; align-items: center; justify-content: center; flex: 1; padding: 24px; }
    .waiting-card { background: white; border-radius: 16px; padding: 32px; box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1); max-width: 400px; width: 100%; text-align: center; }
    .waiting-spinner { width: 64px; height: 64px; border: 4px solid #e2e8f0; border-top-color: #6366f1; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 24px; }
    .url-box { display: flex; gap: 8px; margin-top: 12px; }
    .url-input { flex: 1; padding: 12px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 12px; color: #64748b; background: #f8fafc; }
    .copy-button { padding: 12px 16px; background: #6366f1; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; white-space: nowrap; }
    .copy-button:hover { background: #4f46e5; }
    .cancel-button { margin-top: 24px; padding: 12px 24px; background: transparent; color: #64748b; border: 1px solid #e2e8f0; border-radius: 9999px; font-weight: 500; cursor: pointer; }
    .cancel-button:hover { background: #f8fafc; }
    .back-button { padding: 12px 24px; background: #6366f1; color: white; border: none; border-radius: 9999px; font-weight: 600; cursor: pointer; }
    .back-button:hover { background: #4f46e5; }
    .result-container { display: flex; flex-direction: column; align-items: center; justify-content: center; flex: 1; padding: 24px; }
    .result-card { background: white; border-radius: 16px; padding: 32px; box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1); text-align: center; }
    .play-again-button { margin-top: 24px; padding: 12px 24px; background: #6366f1; color: white; border: none; border-radius: 9999px; font-weight: 600; cursor: pointer; }
    .play-again-button:hover { background: #4f46e5; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    // ========== Configuration ==========
    var APPSYNC_ENDPOINT = 'https://lbianwdzanh3nk2chmqrxllroa.appsync-api.ap-northeast-1.amazonaws.com/graphql';
    var APPSYNC_API_KEY = 'da2-4hkyrubqyrewjiulv462h5jdqi';

    // ========== Constants ==========
    var HEX_SIZE = 38;
    var DIRECTIONS = [
      { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 },
      { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 }
    ];
    var INITIAL_TILES = [
      { q: 0, r: 0 }, { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 },
      { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 }, { q: 2, r: 0 },
      { q: 2, r: -1 }, { q: 2, r: -2 }, { q: 1, r: -2 }, { q: 0, r: -2 },
      { q: -1, r: -1 }, { q: -2, r: 0 }, { q: -2, r: 1 }, { q: -2, r: 2 },
      { q: -1, r: 2 }, { q: 0, r: 2 }, { q: 1, r: 1 }
    ];

    var STRINGS = {
      onlineTitle: '„Ç™„É≥„É©„Ç§„É≥ÂØæÊà¶',
      createGame: '„Ç≤„Éº„É†„Çí‰ΩúÊàê',
      creating: '‰ΩúÊàê‰∏≠...',
      waitingForOpponent: 'ÂØæÊà¶Áõ∏Êâã„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...',
      shareUrl: '„Åì„ÅÆURL„ÇíÂèãÈÅî„Å´ÂÖ±Êúâ:',
      copyUrl: 'URL„Çí„Ç≥„Éî„Éº',
      copied: '„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü!',
      yourTurn: '„ÅÇ„Å™„Åü„ÅÆÁï™',
      opponentTurn: 'Áõ∏Êâã„ÅÆÁï™',
      youWin: '„ÅÇ„Å™„Åü„ÅÆÂãù„Å°!',
      opponentWin: 'Áõ∏Êâã„ÅÆÂãù„Å°!',
      playAgain: '„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅÇ„Åù„Å∂',
      backToLobby: '„É≠„Éì„Éº„Å´Êàª„Çã',
      phaseMoveToken: '1. „Ç≥„Éû„ÇíÊªë„Çâ„Åõ„Çã',
      phaseMoveTile: '2. „Çø„Ç§„É´„ÇíÂãï„Åã„Åô',
      goal: 'Ëá™ÂàÜ„ÅÆ„Ç≥„Éû„Çí 3„Å§ÈÄ£Áµê „Åï„Åõ„Çå„Å∞Âãù„Å°!',
      goalHint: '„ÇØ„É™„ÉÉ„ÇØ„ÅßË©≥„Åó„ÅÑË™¨Êòé„Å∏',
      slideToEdge: 'Á´Ø„Åæ„Åß„Ç≥„Éû„ÇíÊªë„Çâ„Åõ„Çã',
      moveEmptyTile: 'Á©∫„Åç„Çø„Ç§„É´„ÇíÁßªÂãï„Åô„Çã',
      alertBoardSplit: 'Áõ§Èù¢„ÇíÂàÜÊñ≠„Åß„Åç„Åæ„Åõ„Çì',
      connectionError: 'Êé•Á∂ö„Ç®„É©„Éº',
      localGame: '„É≠„Éº„Ç´„É´ÂØæÊà¶',
      you: '„ÅÇ„Å™„Åü',
      opponent: 'Áõ∏Êâã',
      abandoned: 'ÂØæÊà¶Áõ∏Êâã„ÅåÈÄÄÂá∫„Åó„Åæ„Åó„Åü',
      gameNotFound: '„Ç≤„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì',
      gameAlreadyStarted: '„Åì„ÅÆ„Ç≤„Éº„É†„ÅØÊó¢„Å´ÈñãÂßã„Åï„Çå„Å¶„ÅÑ„Åæ„Åô',
      joinFailed: '„Ç≤„Éº„É†„Å∏„ÅÆÂèÇÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'
    };

    // ========== Utility Functions ==========
    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    function getPlayerId() {
      var key = 'nonaga_player_id';
      var playerId = null;
      try {
        playerId = localStorage.getItem(key);
      } catch (e) {
        // localStorage not available
      }
      if (!playerId) {
        playerId = generateUUID();
        try {
          localStorage.setItem(key, playerId);
        } catch (e) {
          // localStorage not available
        }
      }
      return playerId;
    }

    function coordsKey(q, r) {
      return q + ',' + r;
    }

    function hexToPixel(q, r) {
      return {
        x: HEX_SIZE * (3 / 2 * q),
        y: HEX_SIZE * (Math.sqrt(3) / 2 * q + Math.sqrt(3) * r)
      };
    }

    function isAdjacent(a, b) {
      return DIRECTIONS.some(function(d) {
        return a.q + d.q === b.q && a.r + d.r === b.r;
      });
    }

    function getSlideDestinations(piece, tiles, pieces) {
      var tileSet = new Set(tiles.map(function(t) { return coordsKey(t.q, t.r); }));
      var pieceMap = new Map(pieces.map(function(p) { return [coordsKey(p.q, p.r), p]; }));
      var destinations = [];

      DIRECTIONS.forEach(function(dir) {
        var q = piece.q;
        var r = piece.r;
        var lastValid = null;

        while (true) {
          var nextQ = q + dir.q;
          var nextR = r + dir.r;
          var nextKey = coordsKey(nextQ, nextR);

          if (!tileSet.has(nextKey)) break;
          if (pieceMap.has(nextKey)) break;

          q = nextQ;
          r = nextR;
          lastValid = { q: q, r: r };
        }

        if (lastValid && (lastValid.q !== piece.q || lastValid.r !== piece.r)) {
          destinations.push(lastValid);
        }
      });

      return destinations;
    }

    function isBoardConnected(tiles, excludeIndex) {
      var filteredTiles = excludeIndex !== undefined
        ? tiles.filter(function(_, i) { return i !== excludeIndex; })
        : tiles;

      if (filteredTiles.length === 0) return true;

      var tileSet = new Set(filteredTiles.map(function(t) { return coordsKey(t.q, t.r); }));
      var visited = new Set();
      var queue = [filteredTiles[0]];
      visited.add(coordsKey(filteredTiles[0].q, filteredTiles[0].r));

      while (queue.length > 0) {
        var current = queue.shift();
        DIRECTIONS.forEach(function(dir) {
          var neighborKey = coordsKey(current.q + dir.q, current.r + dir.r);
          if (tileSet.has(neighborKey) && !visited.has(neighborKey)) {
            visited.add(neighborKey);
            queue.push({ q: current.q + dir.q, r: current.r + dir.r });
          }
        });
      }

      return visited.size === filteredTiles.length;
    }

    function getValidTileDestinations(selectedIndex, tiles) {
      var remaining = tiles.filter(function(_, i) { return i !== selectedIndex; });
      var candidates = new Map();

      remaining.forEach(function(t) {
        DIRECTIONS.forEach(function(d) {
          var nQ = t.q + d.q;
          var nR = t.r + d.r;
          var key = coordsKey(nQ, nR);

          if (remaining.some(function(rt) { return rt.q === nQ && rt.r === nR; }) ||
              (tiles[selectedIndex].q === nQ && tiles[selectedIndex].r === nR)) {
            return;
          }

          var existing = candidates.get(key);
          if (existing) {
            existing.count++;
          } else {
            candidates.set(key, { q: nQ, r: nR, count: 1 });
          }
        });
      });

      return Array.from(candidates.values())
        .filter(function(c) { return c.count >= 2; })
        .map(function(c) { return { q: c.q, r: c.r }; });
    }

    function getPlayerColor(game, playerId) {
      if (game.hostPlayerId === playerId) {
        return game.hostColor;
      }
      if (game.guestPlayerId === playerId) {
        return game.hostColor === 'red' ? 'blue' : 'red';
      }
      return null;
    }

    function calculateViewBounds(tiles) {
      var padding = 60;
      var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

      tiles.forEach(function(t) {
        var pos = hexToPixel(t.q, t.r);
        minX = Math.min(minX, pos.x);
        maxX = Math.max(maxX, pos.x);
        minY = Math.min(minY, pos.y);
        maxY = Math.max(maxY, pos.y);
      });

      return {
        x: minX - padding,
        y: minY - padding,
        w: maxX - minX + padding * 2,
        h: maxY - minY + padding * 2
      };
    }

    // ========== GraphQL Operations ==========
    var getGameQuery = '\
      query GetGame($gameId: ID!) {\
        getGame(gameId: $gameId) {\
          gameId status hostPlayerId guestPlayerId hostColor\
          tiles { q r }\
          pieces { id player q r }\
          turn phase winner victoryLine lastMoveAt createdAt updatedAt\
        }\
      }\
    ';

    var createGameMutation = '\
      mutation CreateGame($hostPlayerId: String!) {\
        createGame(hostPlayerId: $hostPlayerId) {\
          gameId status hostPlayerId hostColor\
          tiles { q r }\
          pieces { id player q r }\
          turn phase createdAt updatedAt\
        }\
      }\
    ';

    var joinGameMutation = '\
      mutation JoinGame($gameId: ID!, $guestPlayerId: String!) {\
        joinGame(gameId: $gameId, guestPlayerId: $guestPlayerId) {\
          gameId status hostPlayerId guestPlayerId hostColor\
          tiles { q r }\
          pieces { id player q r }\
          turn phase createdAt updatedAt\
        }\
      }\
    ';

    var movePieceMutation = '\
      mutation MovePiece($input: MovePieceInput!) {\
        movePiece(input: $input) {\
          gameId status hostPlayerId guestPlayerId hostColor\
          tiles { q r }\
          pieces { id player q r }\
          turn phase winner victoryLine lastMoveAt updatedAt\
        }\
      }\
    ';

    var moveTileMutation = '\
      mutation MoveTile($input: MoveTileInput!) {\
        moveTile(input: $input) {\
          gameId status hostPlayerId guestPlayerId hostColor\
          tiles { q r }\
          pieces { id player q r }\
          turn phase winner victoryLine lastMoveAt updatedAt\
        }\
      }\
    ';

    var abandonGameMutation = '\
      mutation AbandonGame($gameId: ID!, $playerId: String!) {\
        abandonGame(gameId: $gameId, playerId: $playerId) {\
          gameId status winner phase updatedAt\
        }\
      }\
    ';

    var onGameUpdatedSubscription = '\
      subscription OnGameUpdated($gameId: ID!) {\
        onGameUpdated(gameId: $gameId) {\
          gameId status hostPlayerId guestPlayerId hostColor\
          tiles { q r }\
          pieces { id player q r }\
          turn phase winner victoryLine lastMoveAt updatedAt\
        }\
      }\
    ';

    // ========== GraphQL Client ==========
    function graphqlRequest(query, variables) {
      return fetch(APPSYNC_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': APPSYNC_API_KEY
        },
        body: JSON.stringify({ query: query, variables: variables })
      })
      .then(function(response) {
        if (!response.ok) {
          throw new Error('GraphQL request failed: ' + response.status);
        }
        return response.json();
      })
      .then(function(result) {
        if (result.errors && result.errors.length > 0) {
          throw new Error(result.errors[0].message);
        }
        return result.data;
      });
    }

    function createSubscription(query, variables, onData, onError) {
      var realtimeEndpoint = APPSYNC_ENDPOINT
        .replace('https://', 'wss://')
        .replace('/graphql', '/graphql/realtime');

      var header = btoa(JSON.stringify({
        host: new URL(APPSYNC_ENDPOINT).host,
        'x-api-key': APPSYNC_API_KEY
      }));

      var payload = btoa(JSON.stringify({}));
      var wsUrl = realtimeEndpoint + '?header=' + header + '&payload=' + payload;

      var ws = null;
      var subscriptionId = null;
      var keepAliveTimeout = null;

      function connect() {
        ws = new WebSocket(wsUrl, ['graphql-ws']);

        ws.onopen = function() {
          ws.send(JSON.stringify({ type: 'connection_init' }));
        };

        ws.onmessage = function(event) {
          var message = JSON.parse(event.data);

          switch (message.type) {
            case 'connection_ack':
              subscriptionId = generateUUID();
              ws.send(JSON.stringify({
                id: subscriptionId,
                type: 'start',
                payload: {
                  data: JSON.stringify({ query: query, variables: variables }),
                  extensions: {
                    authorization: {
                      host: new URL(APPSYNC_ENDPOINT).host,
                      'x-api-key': APPSYNC_API_KEY
                    }
                  }
                }
              }));
              break;

            case 'ka':
              if (keepAliveTimeout) clearTimeout(keepAliveTimeout);
              keepAliveTimeout = setTimeout(function() {
                if (ws) ws.close();
                connect();
              }, 300000);
              break;

            case 'data':
              if (message.payload && message.payload.data) {
                onData(message.payload.data);
              }
              break;

            case 'error':
              onError(new Error(message.payload && message.payload.errors && message.payload.errors[0] ? message.payload.errors[0].message : 'Subscription error'));
              break;
          }
        };

        ws.onerror = function() {
          onError(new Error('WebSocket connection error'));
        };

        ws.onclose = function() {
          if (keepAliveTimeout) clearTimeout(keepAliveTimeout);
        };
      }

      connect();

      return {
        unsubscribe: function() {
          if (keepAliveTimeout) clearTimeout(keepAliveTimeout);
          if (ws && subscriptionId) {
            try {
              ws.send(JSON.stringify({ id: subscriptionId, type: 'stop' }));
              ws.close();
            } catch (e) {}
          }
        }
      };
    }

    // ========== URL Routing ==========
    function getGameIdFromPath() {
      var path = window.location.pathname;
      var match = path.match(/\/online\/game\/([^/]+)/);
      return match ? match[1] : null;
    }

    function navigateToGame(gameId) {
      window.history.pushState({}, '', '/online/game/' + gameId);
      window.dispatchEvent(new PopStateEvent('popstate'));
    }

    function navigateToLobby() {
      window.history.pushState({}, '', '/online/');
      window.dispatchEvent(new PopStateEvent('popstate'));
    }

    // ========== React Components ==========
    var useState = React.useState;
    var useEffect = React.useEffect;
    var useCallback = React.useCallback;
    var useRef = React.useRef;
    var useMemo = React.useMemo;

    function Board(props) {
      var tiles = props.tiles;
      var pieces = props.pieces;
      var selectedId = props.selectedId;
      var phase = props.phase;
      var winner = props.winner;
      var victoryLine = props.victoryLine;
      var validDests = props.validDests;
      var viewBounds = props.viewBounds;
      var animatingPiece = props.animatingPiece;
      var animatingTile = props.animatingTile;
      var pieceMap = props.pieceMap;
      var isMyTurn = props.isMyTurn;
      var myColor = props.myColor;
      var onPieceClick = props.onPieceClick;
      var onTileClick = props.onTileClick;
      var onDestinationClick = props.onDestinationClick;

      return (
        <div className="board-container">
          <svg viewBox={viewBounds.x + ' ' + viewBounds.y + ' ' + viewBounds.w + ' ' + viewBounds.h} className="board-svg">
            <defs>
              <filter id="selected-glow" x="-100%" y="-100%" width="300%" height="300%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="6" result="blur1" />
                <feOffset in="blur1" dx="0" dy="0" result="offsetBlur1" />
                <feFlood floodColor="#fbbf24" floodOpacity="1" result="color1" />
                <feComposite in="color1" in2="offsetBlur1" operator="in" result="glow1" />
                <feGaussianBlur in="SourceAlpha" stdDeviation="12" result="blur2" />
                <feOffset in="blur2" dx="0" dy="0" result="offsetBlur2" />
                <feFlood floodColor="#fbbf24" floodOpacity="0.8" result="color2" />
                <feComposite in="color2" in2="offsetBlur2" operator="in" result="glow2" />
                <feGaussianBlur in="SourceAlpha" stdDeviation="18" result="blur3" />
                <feOffset in="blur3" dx="0" dy="0" result="offsetBlur3" />
                <feFlood floodColor="#fbbf24" floodOpacity="0.5" result="color3" />
                <feComposite in="color3" in2="offsetBlur3" operator="in" result="glow3" />
                <feMerge>
                  <feMergeNode in="glow3" />
                  <feMergeNode in="glow2" />
                  <feMergeNode in="glow1" />
                  <feMergeNode in="SourceGraphic" />
                </feMerge>
              </filter>
            </defs>

            <g>
              {tiles.map(function(tile, i) {
                var pos = animatingTile && animatingTile.index === i
                  ? { x: animatingTile.x, y: animatingTile.y }
                  : hexToPixel(tile.q, tile.r);
                var key = coordsKey(tile.q, tile.r);
                var isV = victoryLine.indexOf(key) >= 0;
                var isSelected = phase === 'move_tile' && selectedId === i;
                var isDestHint = phase === 'move_token' && validDests.some(function(d) { return d.q === tile.q && d.r === tile.r; });
                var isSelectableEmpty = !winner && phase === 'move_tile' && !pieceMap.has(key) && isMyTurn;

                var className = 'tile';
                if (isV) className += ' victory-tile ' + winner;
                else if (isSelected) className += ' selected-origin';
                else if (isDestHint) className += ' destination-hint';
                else if (isSelectableEmpty) className += ' selectable-empty';
                if (winner && !isV) className += ' faded';

                return (
                  <polygon
                    key={'tile-' + i}
                    points="-34,-19 0,-38 34,-19 34,19 0,38 -34,19"
                    transform={'translate(' + pos.x + ', ' + pos.y + ')'}
                    className={className}
                    onClick={function() { onTileClick(tile, i); }}
                  />
                );
              })}

              {phase === 'move_tile' && typeof selectedId === 'number' && validDests.map(function(dest, i) {
                var pos = hexToPixel(dest.q, dest.r);
                return (
                  <polygon
                    key={'guide-' + i}
                    points="-30,-16 0,-34 30,-16 30,16 0,34 -30,16"
                    transform={'translate(' + pos.x + ', ' + pos.y + ')'}
                    style={{ fill: '#f0fdf4', stroke: '#34d399', strokeWidth: 2, strokeDasharray: 4, opacity: 0.8, cursor: 'pointer' }}
                    onClick={function() { onDestinationClick(dest); }}
                  />
                );
              })}

              {pieces.map(function(p) {
                var isV = victoryLine.indexOf(coordsKey(p.q, p.r)) >= 0;
                var pos = animatingPiece && animatingPiece.id === p.id
                  ? { x: animatingPiece.x, y: animatingPiece.y }
                  : hexToPixel(p.q, p.r);
                var isMyPiece = p.player === myColor;
                var canSelect = !winner && isMyPiece && phase === 'move_token' && isMyTurn;
                var isSelected = selectedId === p.id;

                var className = 'piece-main ' + p.player;
                if (isSelected) className += ' selected';
                if (isV) className += ' victory-piece';
                if (canSelect) className += ' my-turn';

                return (
                  <g
                    key={p.id}
                    transform={'translate(' + pos.x + ', ' + pos.y + ')'}
                    style={{ cursor: canSelect ? 'pointer' : 'default' }}
                    onClick={function() { onPieceClick(p); }}
                  >
                    <circle r="30" fill="transparent" />
                    <circle
                      r="20"
                      className={className}
                      style={{
                        opacity: winner && !isV ? 0.2 : 1,
                        filter: isSelected ? 'url(#selected-glow)' : 'none'
                      }}
                    />
                    <circle r="14" fill="rgba(0,0,0,0.05)" style={{ pointerEvents: 'none', opacity: winner && !isV ? 0 : 1 }} />
                  </g>
                );
              })}
            </g>
          </svg>
        </div>
      );
    }

    function Lobby() {
      var loadingState = useState(false);
      var loading = loadingState[0];
      var setLoading = loadingState[1];

      var errorState = useState(null);
      var error = errorState[0];
      var setError = errorState[1];

      var playerId = getPlayerId();

      function handleCreateGame() {
        setLoading(true);
        setError(null);
        graphqlRequest(createGameMutation, { hostPlayerId: playerId })
          .then(function(result) {
            navigateToGame(result.createGame.gameId);
          })
          .catch(function(err) {
            console.error('Failed to create game:', err);
            setError('„Ç≤„Éº„É†„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
          })
          .finally(function() {
            setLoading(false);
          });
      }

      return (
        <div className="game-container bg-slate">
          <header className="header">
            <h1 className="game-title">Nonaga</h1>
            <p style={{ color: '#94a3b8', marginTop: 4 }}>{STRINGS.onlineTitle}</p>
          </header>
          <div className="lobby-container">
            <div className="lobby-card">
              <button onClick={handleCreateGame} disabled={loading} className="create-game-button">
                {loading ? STRINGS.creating : STRINGS.createGame}
              </button>
              {error && <p className="error-message">{error}</p>}
              <div className="divider"><span>or</span></div>
              <a href="/" className="local-game-link">‚Üê {STRINGS.localGame}</a>
            </div>
          </div>
        </div>
      );
    }

    function OnlineGame(props) {
      var gameId = props.gameId;

      var gameState = useState(null);
      var game = gameState[0];
      var setGame = gameState[1];

      var loadingState = useState(true);
      var loading = loadingState[0];
      var setLoading = loadingState[1];

      var errorState = useState(null);
      var error = errorState[0];
      var setError = errorState[1];

      var selectedIdState = useState(null);
      var selectedId = selectedIdState[0];
      var setSelectedId = selectedIdState[1];

      var isAnimatingState = useState(false);
      var isAnimating = isAnimatingState[0];
      var setIsAnimating = isAnimatingState[1];

      var animatingPieceState = useState(null);
      var animatingPiece = animatingPieceState[0];
      var setAnimatingPiece = animatingPieceState[1];

      var animatingTileState = useState(null);
      var animatingTile = animatingTileState[0];
      var setAnimatingTile = animatingTileState[1];

      var copiedState = useState(false);
      var copied = copiedState[0];
      var setCopied = copiedState[1];

      var playerId = getPlayerId();
      var subscriptionRef = useRef(null);
      var animationFrameRef = useRef(null);
      var lastUpdateRef = useRef(null);

      var myColor = game ? getPlayerColor(game, playerId) : null;
      var isMyTurn = game && game.status === 'PLAYING' && game.turn === myColor;

      var tiles = game ? game.tiles : [];
      var pieces = game ? game.pieces : [];
      var phase = game ? game.phase : 'waiting';
      var winner = game ? game.winner : null;
      var victoryLine = game && game.victoryLine ? game.victoryLine : [];
      var status = game ? game.status : null;

      var pieceMap = useMemo(function() {
        var map = new Map();
        pieces.forEach(function(p) { map.set(coordsKey(p.q, p.r), p); });
        return map;
      }, [pieces]);

      var viewBounds = useMemo(function() {
        return calculateViewBounds(tiles.length > 0 ? tiles : INITIAL_TILES);
      }, [tiles]);

      var validDests = useMemo(function() {
        if (winner || isAnimating || !isMyTurn) return [];

        if (phase === 'move_token' && typeof selectedId === 'string') {
          var piece = pieces.find(function(p) { return p.id === selectedId; });
          if (!piece) return [];
          return getSlideDestinations(piece, tiles, pieces);
        }

        if (phase === 'move_tile' && typeof selectedId === 'number') {
          return getValidTileDestinations(selectedId, tiles);
        }

        return [];
      }, [selectedId, phase, tiles, pieces, winner, isAnimating, isMyTurn]);

      // Reset selection when game updates
      useEffect(function() {
        if (game && game.updatedAt !== lastUpdateRef.current) {
          lastUpdateRef.current = game.updatedAt;
          setSelectedId(null);
          setIsAnimating(false);
          setAnimatingPiece(null);
          setAnimatingTile(null);
        }
      }, [game]);

      // Initialize game
      useEffect(function() {
        var cancelled = false;

        function subscribeToGame(id) {
          if (subscriptionRef.current) {
            subscriptionRef.current.unsubscribe();
          }

          subscriptionRef.current = createSubscription(
            onGameUpdatedSubscription,
            { gameId: id },
            function(data) {
              if (data.onGameUpdated) {
                setGame(data.onGameUpdated);
              }
            },
            function(err) {
              console.error('Subscription error:', err);
              setError(STRINGS.connectionError);
            }
          );
        }

        function initGame() {
          setLoading(true);
          setError(null);

          graphqlRequest(getGameQuery, { gameId: gameId })
            .then(function(result) {
              if (cancelled) return;
              var existingGame = result.getGame;

              if (!existingGame) {
                setError(STRINGS.gameNotFound);
                setLoading(false);
                return;
              }

              var isHost = existingGame.hostPlayerId === playerId;
              var isGuest = existingGame.guestPlayerId === playerId;

              if (isHost || isGuest) {
                setGame(existingGame);
                subscribeToGame(gameId);
                setLoading(false);
                return;
              }

              if (existingGame.status === 'WAITING') {
                graphqlRequest(joinGameMutation, { gameId: gameId, guestPlayerId: playerId })
                  .then(function(joinResult) {
                    if (cancelled) return;
                    setGame(joinResult.joinGame);
                    subscribeToGame(gameId);
                    setLoading(false);
                  })
                  .catch(function(err) {
                    if (cancelled) return;
                    console.error('Failed to join game:', err);
                    setError(STRINGS.joinFailed);
                    setLoading(false);
                  });
              } else {
                setGame(existingGame);
                setError(STRINGS.gameAlreadyStarted);
                setLoading(false);
              }
            })
            .catch(function(err) {
              if (cancelled) return;
              console.error('Failed to fetch game:', err);
              setError(STRINGS.joinFailed);
              setLoading(false);
            });
        }

        initGame();

        return function() {
          cancelled = true;
          if (subscriptionRef.current) {
            subscriptionRef.current.unsubscribe();
          }
        };
      }, [gameId, playerId]);

      // Animation functions
      function animatePieceMove(pieceId, fromQ, fromR, toQ, toR) {
        var startTime = performance.now();
        var fromPos = hexToPixel(fromQ, fromR);
        var toPos = hexToPixel(toQ, toR);

        function animate(currentTime) {
          var elapsed = currentTime - startTime;
          var progress = Math.min(elapsed / 800, 1);
          var eased = 1 - Math.pow(1 - progress, 3);

          setAnimatingPiece({
            id: pieceId,
            x: fromPos.x + (toPos.x - fromPos.x) * eased,
            y: fromPos.y + (toPos.y - fromPos.y) * eased
          });

          if (progress < 1) {
            animationFrameRef.current = requestAnimationFrame(animate);
          } else {
            setAnimatingPiece(null);
            setIsAnimating(false);
            sendMovePiece(pieceId, toQ, toR);
          }
        }

        animationFrameRef.current = requestAnimationFrame(animate);
      }

      function animateTileMove(tileIndex, fromQ, fromR, toQ, toR) {
        var startTime = performance.now();
        var fromPos = hexToPixel(fromQ, fromR);
        var toPos = hexToPixel(toQ, toR);

        function animate(currentTime) {
          var elapsed = currentTime - startTime;
          var progress = Math.min(elapsed / 800, 1);
          var eased = 1 - Math.pow(1 - progress, 3);

          setAnimatingTile({
            index: tileIndex,
            x: fromPos.x + (toPos.x - fromPos.x) * eased,
            y: fromPos.y + (toPos.y - fromPos.y) * eased
          });

          if (progress < 1) {
            animationFrameRef.current = requestAnimationFrame(animate);
          } else {
            setAnimatingTile(null);
            setIsAnimating(false);
            sendMoveTile(tileIndex, toQ, toR);
          }
        }

        animationFrameRef.current = requestAnimationFrame(animate);
      }

      function sendMovePiece(pieceId, toQ, toR) {
        if (!game) return;
        graphqlRequest(movePieceMutation, {
          input: { gameId: game.gameId, playerId: playerId, pieceId: pieceId, toQ: toQ, toR: toR }
        }).catch(function(err) {
          console.error('Failed to move piece:', err);
          setError('„Ç≥„Éû„ÅÆÁßªÂãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
        });
      }

      function sendMoveTile(fromIndex, toQ, toR) {
        if (!game) return;
        graphqlRequest(moveTileMutation, {
          input: { gameId: game.gameId, playerId: playerId, fromIndex: fromIndex, toQ: toQ, toR: toR }
        }).catch(function(err) {
          console.error('Failed to move tile:', err);
          setError('„Çø„Ç§„É´„ÅÆÁßªÂãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
        });
      }

      function abandonCurrentGame() {
        if (!game) return;
        graphqlRequest(abandonGameMutation, { gameId: game.gameId, playerId: playerId })
          .catch(function(err) {
            console.error('Failed to abandon game:', err);
          });
      }

      // Event handlers
      function handlePieceClick(piece) {
        if (winner || phase !== 'move_token' || piece.player !== myColor || isAnimating || !isMyTurn) {
          return;
        }
        setSelectedId(selectedId === piece.id ? null : piece.id);
      }

      function handleTileClick(tile, index) {
        if (winner || isAnimating || !isMyTurn) return;

        if (phase === 'move_token' && typeof selectedId === 'string') {
          var piece = pieces.find(function(p) { return p.id === selectedId; });
          if (!piece) return;

          var isValidDest = validDests.some(function(d) { return d.q === tile.q && d.r === tile.r; });
          if (isValidDest) {
            setIsAnimating(true);
            animatePieceMove(selectedId, piece.q, piece.r, tile.q, tile.r);
          }
        } else if (phase === 'move_tile' && !pieceMap.has(coordsKey(tile.q, tile.r))) {
          if (isBoardConnected(tiles, index)) {
            setSelectedId(index);
          } else {
            alert(STRINGS.alertBoardSplit);
          }
        }
      }

      function handleDestinationClick(dest) {
        if (phase === 'move_tile' && typeof selectedId === 'number') {
          var tile = tiles[selectedId];
          setIsAnimating(true);
          animateTileMove(selectedId, tile.q, tile.r, dest.q, dest.r);
        }
      }

      function copyUrl() {
        var url = window.location.href;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(url).then(function() {
            setCopied(true);
            setTimeout(function() { setCopied(false); }, 2000);
          }).catch(function() {
            // Fallback for older browsers
            fallbackCopyUrl(url);
          });
        } else {
          fallbackCopyUrl(url);
        }
      }

      function fallbackCopyUrl(url) {
        var textArea = document.createElement('textarea');
        textArea.value = url;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          setCopied(true);
          setTimeout(function() { setCopied(false); }, 2000);
        } catch (e) {}
        document.body.removeChild(textArea);
      }

      function handlePlayAgain() {
        navigateToLobby();
      }

      // Loading state
      if (loading) {
        return (
          <div className="game-container bg-slate">
            <div className="loading-container">
              <div className="loading-spinner" />
              <p>Loading...</p>
            </div>
          </div>
        );
      }

      // Error state (with no game data)
      if (error && !game) {
        return (
          <div className="game-container bg-slate">
            <div className="result-container">
              <div className="result-card">
                <p className="error-message">{error}</p>
                <button onClick={handlePlayAgain} className="back-button" style={{ marginTop: 24 }}>
                  {STRINGS.backToLobby}
                </button>
              </div>
            </div>
          </div>
        );
      }

      // Waiting for opponent
      if (status === 'WAITING') {
        return (
          <div className="game-container bg-slate">
            <header className="header">
              <h1 className="game-title">Nonaga</h1>
            </header>
            <div className="waiting-container">
              <div className="waiting-card">
                <div className="waiting-spinner" />
                <h2>{STRINGS.waitingForOpponent}</h2>
                <p style={{ marginTop: 16, color: '#64748b' }}>{STRINGS.shareUrl}</p>
                <div className="url-box">
                  <input type="text" value={window.location.href} readOnly className="url-input" />
                  <button onClick={copyUrl} className="copy-button">
                    {copied ? STRINGS.copied : STRINGS.copyUrl}
                  </button>
                </div>
                <button onClick={function() { abandonCurrentGame(); navigateToLobby(); }} className="cancel-button">
                  {STRINGS.backToLobby}
                </button>
              </div>
            </div>
          </div>
        );
      }

      // Game abandoned
      if (status === 'ABANDONED') {
        return (
          <div className="game-container bg-slate">
            <div className="result-container">
              <div className="result-card">
                <h2>{STRINGS.abandoned}</h2>
                <button onClick={handlePlayAgain} className="play-again-button">
                  {STRINGS.backToLobby}
                </button>
              </div>
            </div>
          </div>
        );
      }

      // Main game view
      var bgClass = winner === 'red' ? 'bg-rose' : winner === 'blue' ? 'bg-indigo' : 'bg-slate';

      return (
        <div className={'game-container ' + bgClass}>
          <header className="header">
            <h1 className="game-title">Nonaga</h1>
          </header>

          <div className="status-container">
            {winner ? (
              <div className="victory-container">
                <div className={'victory-badge ' + winner}>
                  <span style={{ fontSize: 20, fontWeight: 900 }}>
                    {winner === myColor ? STRINGS.youWin : STRINGS.opponentWin}
                  </span>
                </div>
                <button onClick={handlePlayAgain} className="reset-button">
                  {STRINGS.playAgain}
                </button>
              </div>
            ) : (
              <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                <div style={{ display: 'flex', alignItems: 'center' }}>
                  <div className={'turn-indicator' + (isAnimating ? ' disabled' : '')}>
                    <div className={'player-indicator' + (game && game.turn === 'red' ? ' active' : '')}>
                      <div className="player-dot red" />
                      {myColor === 'red' ? STRINGS.you : STRINGS.opponent}
                    </div>
                    <div style={{ width: 1, height: 12, background: '#e2e8f0' }} />
                    <div className={'player-indicator' + (game && game.turn === 'blue' ? ' active' : '')}>
                      <div className="player-dot blue" />
                      {myColor === 'blue' ? STRINGS.you : STRINGS.opponent}
                    </div>
                  </div>
                </div>
                <div style={{ fontSize: 11, fontWeight: 800, color: '#94a3b8', marginTop: 10, textTransform: 'uppercase', letterSpacing: '0.1em' }}>
                  {isMyTurn
                    ? phase === 'move_token' ? STRINGS.phaseMoveToken : STRINGS.phaseMoveTile
                    : STRINGS.opponentTurn}
                </div>
              </div>
            )}
          </div>

          <Board
            tiles={tiles}
            pieces={pieces}
            selectedId={selectedId}
            phase={phase}
            winner={winner}
            victoryLine={victoryLine}
            validDests={validDests}
            viewBounds={viewBounds}
            animatingPiece={animatingPiece}
            animatingTile={animatingTile}
            pieceMap={pieceMap}
            isMyTurn={isMyTurn}
            myColor={myColor}
            onPieceClick={handlePieceClick}
            onTileClick={handleTileClick}
            onDestinationClick={handleDestinationClick}
          />

          <aside className="rules-container">
            <div className="rules-card">
              <a href="/about/" className="goal-box" style={{ textDecoration: 'none' }}>
                <span style={{ fontSize: 16 }}>üèÜ</span>
                <div>
                  <p>{STRINGS.goal}</p>
                  <p className="goal-hint">{STRINGS.goalHint}</p>
                </div>
              </a>
              <div className="steps-grid">
                <div className="step-item">
                  <span className="step-number">1</span>
                  <p>{STRINGS.slideToEdge}</p>
                </div>
                <div className="step-item">
                  <span className="step-number">2</span>
                  <p>{STRINGS.moveEmptyTile}</p>
                </div>
              </div>
            </div>
          </aside>
        </div>
      );
    }

    function App() {
      var currentPathState = useState(window.location.pathname);
      var currentPath = currentPathState[0];
      var setCurrentPath = currentPathState[1];

      useEffect(function() {
        function handlePopState() {
          setCurrentPath(window.location.pathname);
        }

        window.addEventListener('popstate', handlePopState);
        return function() {
          window.removeEventListener('popstate', handlePopState);
        };
      }, []);

      var gameId = getGameIdFromPath();

      if (gameId) {
        return <OnlineGame gameId={gameId} />;
      }

      return <Lobby />;
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
