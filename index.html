<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, viewport-fit=cover">
    <title>NONAGA</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        /* „Çπ„Éû„Éõ„ÅÆ„Éñ„É©„Ç¶„Ç∂„Éê„ÉºÂØæÁ≠ñ */
        body { 
            -webkit-tap-highlight-color: transparent; 
            background-color: #f8fafc; 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; 
            min-height: 100dvh; 
            overflow-y: auto; /* „Çπ„ÇØ„É≠„Éº„É´„ÇíË®±ÂèØ */
            display: flex; 
            flex-direction: column; 
        }

        #root { display: flex; flex-direction: column; min-height: 100%; flex: 1; }
        
        .game-container { 
            display: flex; 
            flex-direction: column; 
            flex: 1; 
            transition: background-color 1s ease; 
            width: 100%;
        }
        
        .game-container.bg-rose { background-color: #fff1f2; }
        .game-container.bg-indigo { background-color: #eef2ff; }
        .game-container.bg-slate { background-color: #f8fafc; }
        
        .header { padding-top: 1.5rem; display: flex; flex-direction: column; align-items: center; flex-shrink: 0; }
        .game-title { font-size: 1.5rem; font-weight: 900; color: #1e293b; font-style: italic; text-transform: uppercase; letter-spacing: 0.3em; }
        
        .status-container { margin-top: 1rem; display: flex; flex-direction: column; align-items: center; padding: 0 1rem; width: 100%; flex-shrink: 0; min-height: 100px; justify-content: center; }
        .victory-container { display: flex; flex-direction: column; align-items: center; z-index: 50; animation: slideInUp 0.6s cubic-bezier(0.17, 0.89, 0.32, 1.49) forwards; }
        .victory-badge { padding: 0.75rem 2rem; border-radius: 9999px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); border: 4px solid white; color: white; }
        .victory-badge.red { background-color: #f43f5e; }
        .victory-badge.blue { background-color: #6366f1; }
        
        .reset-button { margin-top: 0.75rem; padding: 0.5rem 1.5rem; background-color: #1e293b; color: white; border-radius: 9999px; font-size: 0.75rem; font-weight: 700; border: none; cursor: pointer; }
        
        .turn-indicator { background-color: rgba(255, 255, 255, 0.95); padding: 0.5rem 1.5rem; border-radius: 9999px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); border: 1px solid #f1f5f9; display: flex; align-items: center; gap: 1rem; }
        .player-indicator { display: flex; align-items: center; gap: 0.5rem; opacity: 0.3; transition: all 0.3s ease; }
        .player-indicator.active { opacity: 1; font-weight: 700; transform: scale(1.1); }
        .player-dot { width: 0.8rem; height: 0.8rem; border-radius: 50%; }
        .player-dot.red { background-color: #f43f5e; }
        .player-dot.blue { background-color: #6366f1; }

        .board-container { 
            flex: 1; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            padding: 1rem 0.5rem; 
            touch-action: none; /* „Ç≤„Éº„É†Áõ§Èù¢„ÅÆ„ÅøË™§Êìç‰ΩúÈò≤Ê≠¢ */
            min-height: 350px;
        }
        
        .board-svg { width: 100%; height: auto; max-height: 50vh; overflow: visible; filter: drop-shadow(0 10px 15px rgba(0,0,0,0.1)); }
        
        .tile { transition: all 0.3s ease; fill: white; stroke: #e2e8f0; stroke-width: 1px; }
        .tile.selected-origin { fill: #fee2e2; stroke: #f43f5e; stroke-width: 2px; }
        .tile.destination-hint { fill: #f0fdf4; stroke: #34d399; stroke-dasharray: 2; }
        .tile.selectable-empty { fill: white; stroke: #fbbf24; stroke-width: 2px; animation: tile-glow 2s ease-in-out infinite; }
        .tile.victory-tile { fill: #fff1f2; stroke: #fda4af; stroke-width: 4px; }
        .tile.victory-tile.blue { fill: #eef2ff; stroke: #a5b4fc; }
        .tile.faded { opacity: 0.2; }
        
        .piece-main { transition: all 0.3s ease; stroke: rgba(0,0,0,0.1); }
        .piece-main.red { fill: #f43f5e; }
        .piece-main.blue { fill: #6366f1; }
        .piece-main.selected { stroke: white; stroke-width: 4px; filter: brightness(1.1); }
        .piece-main.victory-piece { animation: piece-pulse 1.2s ease-in-out infinite; }
        .piece-main.my-turn { filter: brightness(1.2) drop-shadow(0 0 10px #fbbf24); }

        @keyframes piece-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
        @keyframes tile-glow { 0%, 100% { stroke-width: 2px; } 50% { stroke-width: 3px; } }
        @keyframes slideInUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes confetti-fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 0; } 10% { opacity: 1; } 100% { transform: translateY(110vh) rotate(360deg); opacity: 0; } }
        
        /* „É´„Éº„É´Âë®„Çä„ÅÆ„Çπ„Çø„Ç§„É´ - ‰∏ãÈÉ®„ÅÆ‰ΩôÁôΩ„ÇíÂº∑Âåñ */
        .rules-container { 
            padding: 1rem 1rem 4rem; /* ‰∏ãÈÉ®„Å´Â§ß„Åç„Å™„Éë„Éá„Ç£„É≥„Ç∞„ÇíÁ¢∫‰øù */
            padding-bottom: calc(4rem + env(safe-area-inset-bottom));
            width: 100%; 
            max-width: 32rem; 
            margin: 0 auto; 
            flex-shrink: 0; 
        }
        .rules-card { background: white; padding: 1rem; border-radius: 1rem; border: 1px solid #f1f5f9; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05); display: flex; flex-direction: column; gap: 0.75rem; }
        .goal-box { background: #fffbeb; padding: 0.75rem; border-radius: 0.75rem; display: flex; gap: 0.5rem; align-items: center; font-size: 0.8rem; color: #78350f; border: 1px solid #fde68a; }
        .steps-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; }
        .step-item { display: flex; gap: 0.5rem; align-items: center; color: #64748b; font-size: 0.7rem; }
        .step-number { width: 1.35rem; height: 1.35rem; border-radius: 50%; background-color: #1e293b; color: white; display: flex; align-items: center; justify-content: center; font-weight: 700; flex-shrink: 0; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef } = React;
        const HEX_SIZE = 38;
        const DIRECTIONS = [{q:1,r:0},{q:1,r:-1},{q:0,r:-1},{q:-1,r:0},{q:-1,r:1},{q:0,r:1}];
        const coordsKey = (q, r) => `${q},${r}`;
        const INITIAL_TILES = [{q:0, r:0}, {q:1, r:0}, {q:1, r:-1}, {q:0, r:-1}, {q:-1, r:0}, {q:-1, r:1}, {q:0, r:1}, {q:2, r:0}, {q:2, r:-1}, {q:2, r:-2}, {q:1, r:-2}, {q:0, r:-2}, {q:-1, r:-1}, {q:-2, r:0}, {q:-2, r:1}, {q:-2, r:2}, {q:-1, r:2}, {q:0, r:2}, {q:1, r:1}];
        
        const INITIAL_PIECES = [
            { id: 'r1', player: 'red',  q: 2,  r: -2 },
            { id: 'b1', player: 'blue', q: 2,  r: 0  },
            { id: 'r2', player: 'red',  q: 0,  r: 2  },
            { id: 'b2', player: 'blue', q: -2, r: 2  },
            { id: 'r3', player: 'red',  q: -2, r: 0  },
            { id: 'b3', player: 'blue', q: 0,  r: -2 }
        ];

        const Confetti = ({ winner }) => {
            const dots = useMemo(() => [...Array(40)].map((_, i) => ({ id: i, left: Math.random() * 100 + '%', delay: Math.random() * 4 + 's', size: (Math.random() * 8 + 4) + 'px', color: winner === 'red' ? '#fb7185' : '#818cf8' })), [winner]);
            return (<div style={{position: 'fixed', inset: 0, pointerEvents: 'none', zIndex: 100}}>{dots.map(d => (<div key={d.id} style={{ position: 'absolute', left: d.left, width: d.size, height: d.size, backgroundColor: d.color, borderRadius: '2px', animation: `confetti-fall 4s linear infinite`, animationDelay: d.delay }} />))}</div>);
        };

        const NonagaGame = () => {
            const [tiles, setTiles] = useState(INITIAL_TILES);
            const [pieces, setPieces] = useState(INITIAL_PIECES);
            const [turn, setTurn] = useState('red');
            const [phase, setPhase] = useState('move_token');
            const [selectedId, setSelectedId] = useState(null);
            const [winner, setWinner] = useState(null);
            const [victoryLine, setVictoryLine] = useState([]);
            const [isAnimating, setIsAnimating] = useState(false);
            const [animatingPiece, setAnimatingPiece] = useState(null);
            const animationFrameRef = useRef(null);

            const resetGame = () => { setTiles(INITIAL_TILES); setPieces(INITIAL_PIECES); setTurn('red'); setPhase('move_token'); setSelectedId(null); setWinner(null); setVictoryLine([]); setIsAnimating(false); setAnimatingPiece(null); };
            const tileMap = useMemo(() => new Set(tiles.map(t => coordsKey(t.q, t.r))), [tiles]);
            const pieceMap = useMemo(() => { const map = new Map(); pieces.forEach(p => map.set(coordsKey(p.q, p.r), p)); return map; }, [pieces]);
            const hexToPixel = (q, r) => ({ x: HEX_SIZE * (3/2 * q), y: HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r) });
            
            const viewBounds = useMemo(() => {
                const padding = 60;
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                tiles.forEach(t => {
                    const { x, y } = hexToPixel(t.q, t.r);
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                });
                return { x: minX - padding, y: minY - padding, w: (maxX - minX) + padding * 2, h: (maxY - minY) + padding * 2 };
            }, [tiles]);

            const getVictoryCoords = (currentPieces, player) => {
                const p = currentPieces.filter(cp => cp.player === player);
                const isAdj = (a, b) => DIRECTIONS.some(d => a.q + d.q === b.q && a.r + d.r === b.r);
                const c01 = isAdj(p[0], p[1]), c12 = isAdj(p[1], p[2]), c20 = isAdj(p[2], p[0]);
                if ((c01 ? 1:0) + (c12 ? 1:0) + (c20 ? 1:0) >= 2) return p.map(item => coordsKey(item.q, item.r));
                return null;
            };

            const animatePieceMove = (pieceId, fromQ, fromR, toQ, toR) => {
                const startTime = performance.now();
                const fromPos = hexToPixel(fromQ, fromR);
                const toPos = hexToPixel(toQ, toR);
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / 450, 1);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    setAnimatingPiece({ id: pieceId, x: fromPos.x + (toPos.x - fromPos.x) * eased, y: fromPos.y + (toPos.y - fromPos.y) * eased });
                    if (progress < 1) animationFrameRef.current = requestAnimationFrame(animate);
                    else {
                        setAnimatingPiece(null); setIsAnimating(false);
                        const nextPieces = pieces.map(p => p.id === pieceId ? { ...p, q: toQ, r: toR } : p);
                        setPieces(nextPieces);
                        const winCoords = getVictoryCoords(nextPieces, turn);
                        if (winCoords) { setWinner(turn); setVictoryLine(winCoords); setPhase('ended'); }
                        else { setPhase('move_tile'); setSelectedId(null); }
                    }
                };
                animationFrameRef.current = requestAnimationFrame(animate);
            };

            const handlePieceClick = (piece) => { if (winner || phase !== 'move_token' || piece.player !== turn || isAnimating) return; setSelectedId(selectedId === piece.id ? null : piece.id); };
            const handleTileClick = (tile, index) => {
                if (winner || isAnimating) return;
                if (phase === 'move_token' && typeof selectedId === 'string') {
                    const piece = pieces.find(p => p.id === selectedId);
                    const moves = DIRECTIONS.map(dir => {
                        let curQ = piece.q, curR = piece.r, lastValid = null;
                        while (true) {
                            const nQ = curQ + dir.q, nR = curR + dir.r;
                            if (!tileMap.has(coordsKey(nQ, nR)) || pieceMap.has(coordsKey(nQ, nR))) break;
                            lastValid = { q: nQ, r: nR }; curQ = nQ; curR = nR;
                        }
                        return lastValid;
                    }).filter(Boolean);
                    if (moves.some(m => m.q === tile.q && m.r === tile.r)) { setIsAnimating(true); animatePieceMove(selectedId, piece.q, piece.r, tile.q, tile.r); }
                } else if (phase === 'move_tile' && !pieceMap.has(coordsKey(tile.q, tile.r))) {
                    const temp = tiles.filter((_, i) => i !== index);
                    const q = [temp[0]], vis = new Set([coordsKey(temp[0].q, temp[0].r)]);
                    while(q.length > 0) {
                        const cur = q.shift();
                        DIRECTIONS.forEach(d => {
                            const k = coordsKey(cur.q+d.q, cur.r+d.r);
                            if(temp.some(t => coordsKey(t.q, t.r) === k) && !vis.has(k)) { vis.add(k); q.push({q:cur.q+d.q, r:cur.r+d.r}); }
                        });
                    }
                    if (vis.size === temp.length) setSelectedId(index);
                    else alert("Áõ§Èù¢„ÇíÂàÜÊñ≠„Åß„Åç„Åæ„Åõ„Çì");
                }
            };

            const validDests = useMemo(() => {
                if (winner || isAnimating) return [];
                if (phase === 'move_token' && typeof selectedId === 'string') {
                    const piece = pieces.find(p => p.id === selectedId);
                    return DIRECTIONS.map(dir => {
                        let curQ = piece.q, curR = piece.r, lastValid = null;
                        while (true) {
                            const nQ = curQ + dir.q, nR = curR + dir.r;
                            if (!tileMap.has(coordsKey(nQ, nR)) || pieceMap.has(coordsKey(nQ, nR))) break;
                            lastValid = { q: nQ, r: nR }; curQ = nQ; curR = nR;
                        }
                        return lastValid;
                    }).filter(Boolean);
                }
                if (phase === 'move_tile' && typeof selectedId === 'number') {
                    const cands = new Map(), rem = tiles.filter((_, i) => i !== selectedId);
                    rem.forEach(t => DIRECTIONS.forEach(d => {
                        const nQ = t.q+d.q, nR = t.r+d.r, k = coordsKey(nQ, nR);
                        if (rem.some(rt => rt.q===nQ && rt.r===nR) || coordsKey(tiles[selectedId].q, tiles[selectedId].r) === k) return;
                        const data = cands.get(k) || { q:nQ, r:nR, c:0 };
                        data.c++; cands.set(k, data);
                    }));
                    return Array.from(cands.values()).filter(c => c.c >= 2);
                }
                return [];
            }, [selectedId, phase, tiles, pieces, tileMap, pieceMap, winner, isAnimating]);

            return (
                <div className={`game-container ${winner === 'red' ? 'bg-rose' : winner === 'blue' ? 'bg-indigo' : 'bg-slate'}`}>
                    {winner && <Confetti winner={winner} />}
                    <header className="header"><h1 className="game-title">Nonaga</h1></header>
                    
                    <div className="status-container">
                        {winner ? (
                            <div className="victory-container">
                                <div className={`victory-badge ${winner}`}><span style={{fontSize:20, fontWeight:900}}>{winner === 'red' ? 'Ëµ§' : 'Èùí'}„ÅÆÂãù„Å°!</span></div>
                                <button onClick={resetGame} className="reset-button">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅÇ„Åù„Å∂</button>
                            </div>
                        ) : (
                            <div style={{display:'flex', flexDirection:'column', alignItems:'center'}}>
                                <div className="turn-indicator">
                                    <div className={`player-indicator ${turn === 'red' ? 'active' : ''}`}><div className="player-dot red" />Ëµ§</div>
                                    <div style={{width:1, height:12, background:'#e2e8f0'}} />
                                    <div className={`player-indicator ${turn === 'blue' ? 'active' : ''}`}><div className="player-dot blue" />Èùí</div>
                                </div>
                                <div style={{fontSize:11, fontWeight:800, color:'#94a3b8', marginTop:10, textTransform:'uppercase', letterSpacing: '0.1em'}}>
                                    {phase === 'move_token' ? "1. „Ç≥„Éû„ÇíÊªë„Çâ„Åõ„Çã" : "2. „Çø„Ç§„É´„ÇíÂãï„Åã„Åô"}
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="board-container">
                        <svg viewBox={`${viewBounds.x} ${viewBounds.y} ${viewBounds.w} ${viewBounds.h}`} className="board-svg">
                            <g>
                                {tiles.map((tile, i) => {
                                    const { x, y } = hexToPixel(tile.q, tile.r);
                                    const key = coordsKey(tile.q, tile.r);
                                    const isV = victoryLine.includes(key);
                                    const isSelected = phase === 'move_tile' && selectedId === i;
                                    const isDestHint = phase === 'move_token' && validDests.some(d => d.q === tile.q && d.r === tile.r);
                                    const isSelectableEmpty = !winner && phase === 'move_tile' && !pieceMap.has(key) && !isAnimating;
                                    return (
                                        <polygon key={`tile-${i}`} points="-34,-19 0,-38 34,-19 34,19 0,38 -34,19" transform={`translate(${x}, ${y})`}
                                            className={`tile ${isV ? `victory-tile ${winner}` : isSelected ? 'selected-origin' : isDestHint ? 'destination-hint' : isSelectableEmpty ? 'selectable-empty' : ''} ${winner && !isV ? 'faded' : ''}`}
                                            onClick={() => handleTileClick(tile, i)} />
                                    );
                                })}
                                {phase === 'move_tile' && typeof selectedId === 'number' && validDests.map((dest, i) => {
                                    const { x, y } = hexToPixel(dest.q, dest.r);
                                    return (
                                        <polygon key={`guide-${i}`} points="-30,-16 0,-34 30,-16 30,16 0,34 -30,16" transform={`translate(${x}, ${y})`}
                                            style={{fill:'#f0fdf4', stroke:'#34d399', strokeWidth:2, strokeDasharray:4, opacity:0.8, cursor:'pointer'}}
                                            onClick={() => {
                                                const nt = [...tiles]; nt[selectedId] = { q: dest.q, r: dest.r };
                                                setTiles(nt); setPhase('move_token'); setTurn(turn === 'red' ? 'blue' : 'red'); setSelectedId(null);
                                            }} />
                                    );
                                })}
                                {pieces.map((p) => {
                                    const isV = victoryLine.includes(coordsKey(p.q, p.r));
                                    const pos = (animatingPiece && animatingPiece.id === p.id) ? { x: animatingPiece.x, y: animatingPiece.y } : hexToPixel(p.q, p.r);
                                    const isMyTurn = !winner && p.player === turn && phase === 'move_token';
                                    return (
                                        <g key={p.id} transform={`translate(${pos.x}, ${pos.y})`} style={{cursor: 'pointer'}} onClick={() => handlePieceClick(p)}>
                                            <circle r="30" fill="transparent" />
                                            <circle r="20" className={`piece-main ${p.player} ${selectedId === p.id ? 'selected' : ''} ${isV ? 'victory-piece' : ''} ${isMyTurn ? 'my-turn' : ''}`} style={{opacity: (winner && !isV) ? 0.2 : 1}} />
                                            <circle r="14" fill="rgba(0,0,0,0.05)" style={{pointerEvents:'none', opacity: (winner && !isV) ? 0 : 1}} />
                                        </g>
                                    );
                                })}
                            </g>
                        </svg>
                    </div>

                    <div className="rules-container">
                        <div className="rules-card">
                            <div className="goal-box">
                                <span style={{fontSize:16}}>üèÜ</span>
                                <p>Ëá™ÂàÜ„ÅÆ„Ç≥„Éû„Çí <strong>3„Å§ÈÄ£Áµê</strong> „Åï„Åõ„Çå„Å∞Âãù„Å°!</p>
                            </div>
                            <div className="steps-grid">
                                <div className="step-item">
                                    <span className="step-number">1</span>
                                    <p>Á´Ø„Åæ„Åß„Ç≥„Éû„ÇíÊªë„Çâ„Åõ„Çã</p>
                                </div>
                                <div className="step-item">
                                    <span className="step-number">2</span>
                                    <p>Á©∫„Åç„Çø„Ç§„É´„ÇíÁßªÂãï„Åô„Çã</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<NonagaGame />);
    </script>
</body>
</html>