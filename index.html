<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, viewport-fit=cover">
    <title>NONAGA - Clear Color Distinction</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { -webkit-tap-highlight-color: transparent; background-color: #f8fafc; font-family: 'Inter', system-ui, sans-serif; margin: 0; padding: 0; min-height: 100vh; overflow-x: hidden; }
        .board-container { touch-action: none; }
        .shadow-soft { box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1); }
        .piece-group { transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); will-change: transform; }
        @keyframes piece-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
        .animate-victory-piece { animation: piece-pulse 1.2s ease-in-out infinite; }
        @keyframes slideInUp { 0% { transform: translateY(20px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
        .animate-victory-text { animation: slideInUp 0.6s cubic-bezier(0.17, 0.89, 0.32, 1.49) forwards; }
        .confetti { position: fixed; width: 10px; height: 10px; border-radius: 2px; animation: confetti-fall 4s linear infinite; pointer-events: none; z-index: 10; }
        @keyframes confetti-fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 0; } 10% { opacity: 1; } 100% { transform: translateY(110vh) rotate(360deg); opacity: 0; } }
        .game-title { letter-spacing: 0.3em; text-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useMemo } = React;
        const HEX_SIZE = 38;
        const DIRECTIONS = [{q:1,r:0},{q:1,r:-1},{q:0,r:-1},{q:-1,r:0},{q:-1,r:1},{q:0,r:1}];
        const coordsKey = (q, r) => `${q},${r}`;

        const INITIAL_TILES = [
            {q:0, r:0}, {q:1, r:0}, {q:1, r:-1}, {q:0, r:-1}, {q:-1, r:0}, {q:-1, r:1}, {q:0, r:1},
            {q:2, r:0}, {q:2, r:-1}, {q:2, r:-2}, {q:1, r:-2}, {q:0, r:-2}, 
            {q:-1, r:-1}, {q:-2, r:0}, {q:-2, r:1}, {q:-2, r:2}, {q:-1, r:2}, {q:0, r:2}, {q:1, r:1}
        ];

        const PLAYERS = {
            RED: { id: 'red', color: 'fill-rose-500', bg: 'bg-rose-500', border: 'stroke-rose-400', light: 'fill-rose-50', name: 'Ëµ§' },
            BLUE: { id: 'blue', color: 'fill-indigo-500', bg: 'bg-indigo-500', border: 'stroke-indigo-400', light: 'fill-indigo-50', name: 'Èùí' }
        };

        const INITIAL_PIECES = [
            { id: 'r1', player: 'red', q: -1, r: -1 }, { id: 'r2', player: 'red', q: 1, r: -2 }, { id: 'r3', player: 'red', q: 2, r: 0 },
            { id: 'b1', player: 'blue', q: -2, r: 0 }, { id: 'b2', player: 'blue', q: -1, r: 2 }, { id: 'b3', player: 'blue', q: 1, r: 1 }
        ];

        const Confetti = ({ winner }) => {
            const dots = useMemo(() => [...Array(40)].map((_, i) => ({
                id: i, left: Math.random() * 100 + '%', delay: Math.random() * 4 + 's', size: (Math.random() * 8 + 4) + 'px',
                color: Math.random() > 0.5 ? (winner === 'red' ? 'bg-rose-400' : 'bg-indigo-400') : 'bg-amber-300'
            })), [winner]);
            return <div className="fixed inset-0 pointer-events-none">{dots.map(d => <div key={d.id} className={`confetti ${d.color}`} style={{ left: d.left, animationDelay: d.delay, width: d.size, height: d.size }} />)}</div>;
        };

        const NonagaGame = () => {
            const [tiles, setTiles] = useState(INITIAL_TILES);
            const [pieces, setPieces] = useState(INITIAL_PIECES);
            const [turn, setTurn] = useState('red');
            const [phase, setPhase] = useState('move_token');
            const [selectedId, setSelectedId] = useState(null);
            const [winner, setWinner] = useState(null);
            const [victoryLine, setVictoryLine] = useState([]);
            const [isAnimating, setIsAnimating] = useState(false);

            const tileMap = useMemo(() => new Set(tiles.map(t => coordsKey(t.q, t.r))), [tiles]);
            const pieceMap = useMemo(() => {
                const map = new Map();
                pieces.forEach(p => map.set(coordsKey(p.q, p.r), p));
                return map;
            }, [pieces]);

            const hexToPixel = (q, r) => ({ x: HEX_SIZE * (3/2 * q), y: HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r) });

            const viewBounds = useMemo(() => {
                const padding = 60;
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                tiles.forEach(t => {
                    const { x, y } = hexToPixel(t.q, t.r);
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                });
                return { x: minX - padding, y: minY - padding, w: (maxX - minX) + padding * 2, h: (maxY - minY) + padding * 2 };
            }, [tiles]);

            const getVictoryCoords = (currentPieces, player) => {
                const p = currentPieces.filter(cp => cp.player === player);
                const isAdj = (a, b) => DIRECTIONS.some(d => a.q + d.q === b.q && a.r + d.r === b.r);
                const c01 = isAdj(p[0], p[1]), c12 = isAdj(p[1], p[2]), c20 = isAdj(p[2], p[0]);
                if ((c01 ? 1:0) + (c12 ? 1:0) + (c20 ? 1:0) >= 2) return p.map(item => coordsKey(item.q, item.r));
                return null;
            };

            const handlePieceClick = (piece) => {
                if (winner || phase !== 'move_token' || piece.player !== turn || isAnimating) return;
                setSelectedId(selectedId === piece.id ? null : piece.id);
            };

            const handleTileClick = (tile, index) => {
                if (winner || isAnimating) return;
                if (phase === 'move_token' && typeof selectedId === 'string') {
                    const piece = pieces.find(p => p.id === selectedId);
                    const moves = DIRECTIONS.map(dir => {
                        let curQ = piece.q, curR = piece.r, lastValid = null;
                        while (true) {
                            const nQ = curQ + dir.q, nR = curR + dir.r;
                            if (!tileMap.has(coordsKey(nQ, nR)) || pieceMap.has(coordsKey(nQ, nR))) break;
                            lastValid = { q: nQ, r: nR }; curQ = nQ; curR = nR;
                        }
                        return lastValid;
                    }).filter(Boolean);
                    if (moves.some(m => m.q === tile.q && m.r === tile.r)) {
                        setIsAnimating(true);
                        const nextPieces = pieces.map(p => p.id === selectedId ? { ...p, q: tile.q, r: tile.r } : p);
                        setPieces(nextPieces);
                        setTimeout(() => {
                            setIsAnimating(false);
                            const winCoords = getVictoryCoords(nextPieces, turn);
                            if (winCoords) { setWinner(turn); setVictoryLine(winCoords); setPhase('ended'); }
                            else { setPhase('move_tile'); setSelectedId(null); }
                        }, 600);
                    }
                } else if (phase === 'move_tile' && !pieces.some(p => p.q === tile.q && p.r === tile.r)) {
                    const temp = tiles.filter((_, i) => i !== index);
                    const q = [temp[0]], vis = new Set([coordsKey(temp[0].q, temp[0].r)]);
                    while(q.length > 0) {
                        const cur = q.shift();
                        DIRECTIONS.forEach(d => {
                            const k = coordsKey(cur.q+d.q, cur.r+d.r);
                            if(temp.some(t => coordsKey(t.q, t.r) === k) && !vis.has(k)) { vis.add(k); q.push({q:cur.q+d.q, r:cur.r+d.r}); }
                        });
                    }
                    if (vis.size === temp.length) setSelectedId(index);
                    else alert("Áõ§Èù¢„ÅåÂàÜÊñ≠„Åï„Çå„Çã„Åü„ÇÅÁßªÂãï„Åß„Åç„Åæ„Åõ„ÇìÔºÅ");
                }
            };

            const getValidTilePlacements = (idx) => {
                const cands = new Map(), rem = tiles.filter((_, i) => i !== idx), origK = coordsKey(tiles[idx].q, tiles[idx].r);
                rem.forEach(t => DIRECTIONS.forEach(d => {
                    const nQ = t.q+d.q, nR = t.r+d.r, k = coordsKey(nQ, nR);
                    if (rem.some(rt => rt.q===nQ && rt.r===nR) || k===origK) return;
                    const data = cands.get(k) || { q:nQ, r:nR, neighbors:0 };
                    data.neighbors++; cands.set(k, data);
                }));
                return Array.from(cands.values()).filter(c => c.neighbors >= 2);
            };

            let validDests = [];
            if (phase === 'move_token' && typeof selectedId === 'string' && !isAnimating) {
                const piece = pieces.find(p => p.id === selectedId);
                DIRECTIONS.forEach(dir => {
                    let curQ = piece.q, curR = piece.r, lastValid = null;
                    while (true) {
                        const nQ = curQ + dir.q, nR = curR + dir.r;
                        if (!tileMap.has(coordsKey(nQ, nR)) || pieceMap.has(coordsKey(nQ, nR))) break;
                        lastValid = { q: nQ, r: nR }; curQ = nQ; curR = nR;
                    }
                    if (lastValid) validDests.push(lastValid);
                });
            } else if (phase === 'move_tile' && typeof selectedId === 'number') {
                validDests = getValidTilePlacements(selectedId);
            }

            return (
                <div className={`flex flex-col min-h-screen w-full items-center overflow-y-auto transition-colors duration-1000 ${winner === 'red' ? 'bg-rose-50' : winner === 'blue' ? 'bg-indigo-50' : 'bg-slate-50'}`}>
                    {winner && <Confetti winner={winner} />}
                    <header className="pt-8 pb-4 flex flex-col items-center">
                        <h1 className="game-title text-4xl font-black text-slate-800 italic uppercase">Nonaga</h1>
                        <div className="w-12 h-1 bg-slate-800 mt-1 rounded-full opacity-20"></div>
                    </header>

                    <div className="sticky top-4 z-20 flex flex-col items-center mb-4 px-4 w-full">
                        {winner ? (
                            <div className="animate-victory-text flex flex-col items-center">
                                <div className={`px-8 py-3 rounded-full shadow-2xl border-4 border-white ${winner === 'red' ? 'bg-rose-500' : 'bg-indigo-500'} text-white`}>
                                    <span className="text-3xl font-black">{PLAYERS[winner.toUpperCase()].name}„ÅÆÂãù„Å°ÔºÅ</span>
                                </div>
                                <button onClick={() => window.location.reload()} className="mt-4 bg-slate-800 text-white py-2 px-6 rounded-full text-xs font-bold tracking-widest shadow-lg">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅÇ„Åù„Å∂</button>
                            </div>
                        ) : (
                            <div className="bg-white/95 backdrop-blur px-6 py-2 rounded-full shadow-soft border border-slate-100 flex items-center gap-4">
                                <div className={`flex items-center gap-2 transition-all ${turn === 'red' ? 'opacity-100 scale-110' : 'opacity-30'}`}><div className="w-4 h-4 rounded-full bg-rose-500" />Ëµ§„ÅÆÁï™</div>
                                <div className="h-4 w-px bg-slate-200" />
                                <div className={`flex items-center gap-2 transition-all ${turn === 'blue' ? 'opacity-100 scale-110' : 'opacity-30'}`}><div className="w-4 h-4 rounded-full bg-indigo-500" />Èùí„ÅÆÁï™</div>
                            </div>
                        )}
                        {!winner && <div className="mt-2 text-xs font-bold text-slate-500 bg-white/60 px-4 py-1 rounded-full tracking-wider">{phase === 'move_token' ? "STEP 1. „Ç≥„Éû„ÇíÊªë„Çâ„Åõ„Çã" : "STEP 2. „Çø„Ç§„É´„ÇíÁßªÂãï„Åô„Çã"}</div>}
                    </div>

                    <div className={`board-container w-full max-w-2xl flex items-center justify-center p-4 ${winner ? 'scale-105' : ''}`}>
                        <svg viewBox={`${viewBounds.x} ${viewBounds.y} ${viewBounds.w} ${viewBounds.h}`} className="w-full h-auto max-h-[55vh] drop-shadow-2xl select-none">
                            <g>
                                {tiles.map((tile, i) => {
                                    const { x, y } = hexToPixel(tile.q, tile.r), key = coordsKey(tile.q, tile.r);
                                    const isSelected = phase === 'move_tile' && selectedId === i;
                                    const isDest = phase === 'move_token' && validDests.some(d => d.q === tile.q && d.r === tile.r);
                                    const isVictoryTile = victoryLine.includes(key);
                                    const winnerConfig = winner ? PLAYERS[winner.toUpperCase()] : null;
                                    
                                    return (
                                        <polygon key={`tile-${i}`} points="-34,-19 0,-38 34,-19 34,19 0,38 -34,19" transform={`translate(${x}, ${y})`}
                                            className={`transition-all duration-500 ${winner || isAnimating ? 'pointer-events-none' : 'cursor-pointer'} 
                                                ${isVictoryTile ? `${winnerConfig.light} ${winnerConfig.border} stroke-[4px]` : 
                                                  isSelected ? 'fill-rose-100 stroke-rose-500 stroke-[3px]' : // „Çø„Ç§„É´ÈÅ∏ÊäûÊôÇ: „É≠„Éº„Ç∫Ëâ≤
                                                  isDest ? 'fill-emerald-50 stroke-emerald-400 stroke-2' :     // „Ç≥„ÉûÁßªÂãïÂÖà: „Ç®„É°„É©„É´„Éâ
                                                  'fill-white stroke-slate-200'}
                                                ${winner && !isVictoryTile ? 'opacity-30' : 'opacity-100'}`}
                                            onClick={() => handleTileClick(tile, i)} />
                                    );
                                })}
                                {phase === 'move_tile' && typeof selectedId === 'number' && validDests.map((dest, i) => {
                                    const { x, y } = hexToPixel(dest.q, dest.r);
                                    return (
                                        <polygon key={`guide-${i}`} points="-30,-16 0,-34 30,-16 30,16 0,34 -30,16" transform={`translate(${x}, ${y})`}
                                            className="fill-sky-50 stroke-sky-500 stroke-2 stroke-dasharray-4 opacity-70 animate-pulse cursor-pointer" // „Çø„Ç§„É´ÁßªÂãïÂÖà: „Çπ„Ç´„Ç§„Éñ„É´„Éº
                                            onClick={() => {
                                                const newTiles = [...tiles]; newTiles[selectedId] = { q: dest.q, r: dest.r };
                                                setTiles(newTiles); setPhase('move_token'); setTurn(turn === 'red' ? 'blue' : 'red'); setSelectedId(null);
                                            }} />
                                    );
                                })}
                                {pieces.map((p) => {
                                    const { x, y } = hexToPixel(p.q, p.r), key = coordsKey(p.q, p.r);
                                    const config = PLAYERS[p.player.toUpperCase()], isVictoryPiece = victoryLine.includes(key);
                                    return (
                                        <g key={p.id} transform={`translate(${x}, ${y})`} className={`piece-group ${winner || isAnimating ? '' : 'piece-hit-area'}`} onClick={() => handlePieceClick(p)}>
                                            <circle r="25" className="fill-transparent" />
                                            <circle r="20" className={`${config.color} ${selectedId === p.id ? 'stroke-white stroke-[4px]' : 'stroke-black/10 stroke-1'} shadow-xl ${winner && !isVictoryPiece ? 'opacity-30' : 'opacity-100'} ${isVictoryPiece ? 'animate-victory-piece' : ''}`} />
                                            <circle r="14" className={`fill-black/5 pointer-events-none ${winner && !isVictoryPiece ? 'opacity-0' : 'opacity-100'}`} />
                                        </g>
                                    );
                                })}
                            </g>
                        </svg>
                    </div>

                    <div className="flex flex-col items-center gap-6 px-4 py-8 w-full max-w-xl mb-12">
                        <div className="bg-white rounded-3xl p-8 shadow-soft border border-slate-100 w-full">
                            <div className="flex items-center gap-2 mb-6">
                                <div className="w-1.5 h-6 bg-slate-800 rounded-full"></div>
                                <h3 className="text-lg font-black text-slate-800 tracking-tight uppercase">ÈÅä„Å≥Êñπ„ÅÆ„É´„Éº„É´</h3>
                            </div>
                            <div className="space-y-6">
                                <div className="bg-amber-50 border border-amber-200 rounded-2xl p-4 flex items-start gap-3">
                                    <span className="text-2xl mt-1">üèÜ</span>
                                    <div>
                                        <p className="text-amber-900 font-bold text-sm">ÂãùÂà©Êù°‰ª∂</p>
                                        <p className="text-amber-800 text-sm leading-relaxed">
                                            Ëá™ÂàÜ„ÅÆ„Ç≥„Éû„Çí <span className="bg-amber-200 px-1 rounded font-black text-amber-950">3„Å§‰∏ÄÂàó„Å´ÈÄ£Áµê</span> „Åï„Åõ„Çå„Å∞Âãù„Å°ÔºÅ
                                        </p>
                                    </div>
                                </div>
                                <div className="grid grid-cols-1 gap-4">
                                    <div className="flex gap-4 items-start">
                                        <span className="flex-shrink-0 w-8 h-8 rounded-full bg-slate-800 text-white flex items-center justify-center font-black text-sm">1</span>
                                        <div>
                                            <p className="font-bold text-slate-800 text-sm">„Ç≥„Éû„ÇíÊªë„Çâ„Åõ„Çã</p>
                                            <p className="text-slate-500 text-xs mt-1">‰ªñ„ÅÆ„Ç≥„Éû„ÇÑÂ£Å„Å´„Å∂„Å§„Åã„Çã„Åæ„ÅßÁúü„Å£Áõ¥„ÅêÈÄ≤„Åø„Åæ„Åô„ÄÇ</p>
                                        </div>
                                    </div>
                                    <div className="flex gap-4 items-start">
                                        <span className="flex-shrink-0 w-8 h-8 rounded-full bg-slate-800 text-white flex items-center justify-center font-black text-sm">2</span>
                                        <div>
                                            <p className="font-bold text-slate-800 text-sm">„Çø„Ç§„É´„ÇíÁßªÂãï„Åô„Çã</p>
                                            <p className="text-slate-500 text-xs mt-1">Á©∫„ÅÑ„Å¶„ÅÑ„Çã„Çø„Ç§„É´„Çí1Êûö„ÄÅÂà•„ÅÆÂ†¥ÊâÄ„Å´‰ªò„ÅëÊõø„Åà„Åæ„Åô„ÄÇ</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<NonagaGame />);
    </script>
</body>
</html>