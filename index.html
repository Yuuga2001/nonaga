<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, viewport-fit=cover">
    <title>NONAGA - Bouncy Physics Edition</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { -webkit-tap-highlight-color: transparent; background-color: #f8fafc; font-family: 'Inter', system-ui, sans-serif; margin: 0; padding: 0; min-height: 100vh; overflow-x: hidden; }
        .board-container { touch-action: none; }
        .shadow-soft { box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1); }
        
        /* バインバイン！という弾性アニメーション */
        .piece-group {
            /* linear() を使った高度なイージングで弾力を表現 (モダンブラウザ用) */
            /* 未対応ブラウザ向けに spring のような挙動を cubic-bezier で近似 */
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            will-change: transform;
        }

        /* 勝利時のふわふわアニメーション */
        @keyframes slideInUp { 0% { transform: translateY(20px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
        .animate-victory-text { animation: slideInUp 0.6s cubic-bezier(0.17, 0.89, 0.32, 1.49) forwards; }
        
        @keyframes confetti-fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 0; } 10% { opacity: 1; } 100% { transform: translateY(110vh) rotate(360deg); opacity: 0; } }
        .confetti { position: fixed; width: 10px; height: 10px; border-radius: 2px; animation: confetti-fall 4s linear infinite; pointer-events: none; z-index: 10; }
        .game-title { letter-spacing: 0.3em; text-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useMemo } = React;
        const HEX_SIZE = 38;
        const DIRECTIONS = [{q:1,r:0},{q:1,r:-1},{q:0,r:-1},{q:-1,r:0},{q:-1,r:1},{q:0,r:1}];
        const coordsKey = (q, r) => `${q},${r}`;

        const INITIAL_TILES = [
            {q:0, r:0}, {q:1, r:0}, {q:1, r:-1}, {q:0, r:-1}, {q:-1, r:0}, {q:-1, r:1}, {q:0, r:1},
            {q:2, r:0}, {q:2, r:-1}, {q:2, r:-2}, {q:1, r:-2}, {q:0, r:-2}, 
            {q:-1, r:-1}, {q:-2, r:0}, {q:-2, r:1}, {q:-2, r:2}, {q:-1, r:2}, {q:0, r:2}, {q:1, r:1}
        ];

        const PLAYERS = {
            RED: { id: 'red', color: 'fill-rose-500', bg: 'bg-rose-500', name: '赤' },
            BLUE: { id: 'blue', color: 'fill-indigo-500', bg: 'bg-indigo-500', name: '青' }
        };

        const INITIAL_PIECES = [
            { id: 'r1', player: 'red', q: -1, r: -1 }, { id: 'r2', player: 'red', q: 1, r: -2 }, { id: 'r3', player: 'red', q: 2, r: 0 },
            { id: 'b1', player: 'blue', q: -2, r: 0 }, { id: 'b2', player: 'blue', q: -1, r: 2 }, { id: 'b3', player: 'blue', q: 1, r: 1 }
        ];

        const Confetti = ({ winner }) => {
            const dots = useMemo(() => [...Array(40)].map((_, i) => ({
                id: i, left: Math.random() * 100 + '%', delay: Math.random() * 4 + 's', size: (Math.random() * 8 + 4) + 'px',
                color: Math.random() > 0.5 ? (winner === 'red' ? 'bg-rose-400' : 'bg-indigo-400') : 'bg-amber-300'
            })), [winner]);
            return <div className="fixed inset-0 pointer-events-none">{dots.map(d => <div key={d.id} className={`confetti ${d.color}`} style={{ left: d.left, animationDelay: d.delay, width: d.size, height: d.size }} />)}</div>;
        };

        const NonagaGame = () => {
            const [tiles, setTiles] = useState(INITIAL_TILES);
            const [pieces, setPieces] = useState(INITIAL_PIECES);
            const [turn, setTurn] = useState('red');
            const [phase, setPhase] = useState('move_token');
            const [selectedId, setSelectedId] = useState(null);
            const [winner, setWinner] = useState(null);
            const [isAnimating, setIsAnimating] = useState(false);

            const tileMap = useMemo(() => new Set(tiles.map(t => coordsKey(t.q, t.r))), [tiles]);
            const pieceMap = useMemo(() => {
                const map = new Map();
                pieces.forEach(p => map.set(coordsKey(p.q, p.r), p));
                return map;
            }, [pieces]);

            const hexToPixel = (q, r) => ({ x: HEX_SIZE * (3/2 * q), y: HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r) });

            const viewBounds = useMemo(() => {
                const padding = 60;
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                tiles.forEach(t => {
                    const { x, y } = hexToPixel(t.q, t.r);
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                });
                return { x: minX - padding, y: minY - padding, w: (maxX - minX) + padding * 2, h: (maxY - minY) + padding * 2 };
            }, [tiles]);

            const getValidTilePlacements = (movingTileIndex) => {
                const candidates = new Map();
                const remaining = tiles.filter((_, i) => i !== movingTileIndex);
                const originalKey = coordsKey(tiles[movingTileIndex].q, tiles[movingTileIndex].r);
                remaining.forEach(t => {
                    DIRECTIONS.forEach(dir => {
                        const nQ = t.q + dir.q, nR = t.r + dir.r, key = coordsKey(nQ, nR);
                        if (remaining.some(rt => rt.q === nQ && rt.r === nR)) return;
                        if (key === originalKey) return; 
                        const data = candidates.get(key) || { q: nQ, r: nR, neighbors: 0 };
                        data.neighbors++; candidates.set(key, data);
                    });
                });
                return Array.from(candidates.values()).filter(c => c.neighbors >= 2);
            };

            const handlePieceClick = (piece) => {
                if (winner || phase !== 'move_token' || piece.player !== turn || isAnimating) return;
                setSelectedId(selectedId === piece.id ? null : piece.id);
            };

            const handleTileClick = (tile, index) => {
                if (winner || isAnimating) return;
                
                if (phase === 'move_token' && typeof selectedId === 'string') {
                    const piece = pieces.find(p => p.id === selectedId);
                    const moves = DIRECTIONS.map(dir => {
                        let curQ = piece.q, curR = piece.r, lastValid = null;
                        while (true) {
                            const nQ = curQ + dir.q, nR = curR + dir.r;
                            if (!tileMap.has(coordsKey(nQ, nR)) || pieceMap.has(coordsKey(nQ, nR))) break;
                            lastValid = { q: nQ, r: nR }; curQ = nQ; curR = nR;
                        }
                        return lastValid;
                    }).filter(Boolean);

                    if (moves.some(m => m.q === tile.q && m.r === tile.r)) {
                        setIsAnimating(true);
                        const newPieces = pieces.map(p => p.id === selectedId ? { ...p, q: tile.q, r: tile.r } : p);
                        setPieces(newPieces);
                        
                        // アニメーション完了（バウンドが落ち着く時間）を待つ
                        setTimeout(() => {
                            setIsAnimating(false);
                            const p = newPieces.filter(cp => cp.player === turn);
                            const isAdj = (a, b) => DIRECTIONS.some(d => a.q + d.q === b.q && a.r + d.r === b.r);
                            if (((isAdj(p[0], p[1]) ? 1:0) + (isAdj(p[1], p[2]) ? 1:0) + (isAdj(p[2], p[0]) ? 1:0)) >= 2) { 
                                setWinner(turn); setPhase('ended'); 
                            } else { 
                                setPhase('move_tile'); setSelectedId(null); 
                            }
                        }, 600); 
                    }
                } else if (phase === 'move_tile' && !pieces.some(p => p.q === tile.q && p.r === tile.r)) {
                    const temp = tiles.filter((_, i) => i !== index);
                    const start = temp[0];
                    const q = [start], vis = new Set([coordsKey(start.q, start.r)]);
                    while(q.length > 0) {
                        const cur = q.shift();
                        DIRECTIONS.forEach(d => {
                            const k = coordsKey(cur.q+d.q, cur.r+d.r);
                            if(temp.some(t => coordsKey(t.q, t.r) === k) && !vis.has(k)) { vis.add(k); q.push({q:cur.q+d.q, r:cur.r+d.r}); }
                        });
                    }
                    if (vis.size === temp.length) setSelectedId(index);
                    else alert("盤面が分断されるため移動できません！");
                }
            };

            let validDests = [];
            if (phase === 'move_token' && typeof selectedId === 'string' && !isAnimating) {
                const piece = pieces.find(p => p.id === selectedId);
                DIRECTIONS.forEach(dir => {
                    let curQ = piece.q, curR = piece.r, lastValid = null;
                    while (true) {
                        const nQ = curQ + dir.q, nR = curR + dir.r;
                        if (!tileMap.has(coordsKey(nQ, nR)) || pieceMap.has(coordsKey(nQ, nR))) break;
                        lastValid = { q: nQ, r: nR }; curQ = nQ; curR = nR;
                    }
                    if (lastValid) validDests.push(lastValid);
                });
            }
            if (phase === 'move_tile' && typeof selectedId === 'number') {
                validDests = getValidTilePlacements(selectedId);
            }

            return (
                <div className={`flex flex-col min-h-screen w-full items-center overflow-y-auto transition-colors duration-1000 ${winner === 'red' ? 'bg-rose-50' : winner === 'blue' ? 'bg-indigo-50' : 'bg-slate-50'}`}>
                    {winner && <Confetti winner={winner} />}
                    <header className="pt-8 pb-4 flex flex-col items-center">
                        <h1 className="game-title text-4xl font-black text-slate-800 italic uppercase">Nonaga</h1>
                        <div className="w-12 h-1 bg-slate-800 mt-1 rounded-full opacity-20"></div>
                    </header>

                    <div className="sticky top-4 z-20 flex flex-col items-center mb-4 px-4 w-full">
                        {winner ? (
                            <div className="animate-victory-text flex flex-col items-center">
                                <div className={`px-8 py-3 rounded-full shadow-2xl border-4 border-white ${winner === 'red' ? 'bg-rose-500' : 'bg-indigo-500'} text-white`}>
                                    <span className="text-3xl font-black">{PLAYERS[winner.toUpperCase()].name}の勝ち！</span>
                                </div>
                                <button onClick={() => window.location.reload()} className="mt-4 bg-slate-800 text-white py-2 px-6 rounded-full text-xs font-bold tracking-widest shadow-lg">もう一度あそぶ</button>
                            </div>
                        ) : (
                            <div className="bg-white/95 backdrop-blur px-6 py-2 rounded-full shadow-soft border border-slate-100 flex items-center gap-4">
                                <div className={`flex items-center gap-2 transition-all ${turn === 'red' ? 'opacity-100 scale-110' : 'opacity-30'}`}><div className="w-4 h-4 rounded-full bg-rose-500" />赤の番</div>
                                <div className="h-4 w-px bg-slate-200" />
                                <div className={`flex items-center gap-2 transition-all ${turn === 'blue' ? 'opacity-100 scale-110' : 'opacity-30'}`}><div className="w-4 h-4 rounded-full bg-indigo-500" />青の番</div>
                            </div>
                        )}
                        {!winner && <div className="mt-2 text-xs font-bold text-slate-500 bg-white/60 px-4 py-1 rounded-full">{phase === 'move_token' ? "1. コマを滑らせる" : "2. タイルを移動する"}</div>}
                    </div>

                    <div className={`board-container w-full max-w-2xl flex items-center justify-center p-4 ${winner ? 'scale-105' : ''}`}>
                        <svg viewBox={`${viewBounds.x} ${viewBounds.y} ${viewBounds.w} ${viewBounds.h}`} className="w-full h-auto max-h-[55vh] drop-shadow-2xl select-none">
                            <g>
                                {tiles.map((tile, i) => {
                                    const { x, y } = hexToPixel(tile.q, tile.r);
                                    const isSelected = phase === 'move_tile' && selectedId === i;
                                    const isDest = phase === 'move_token' && validDests.some(d => d.q === tile.q && d.r === tile.r);
                                    return (
                                        <polygon key={i} points="-34,-19 0,-38 34,-19 34,19 0,38 -34,19" transform={`translate(${x}, ${y})`}
                                            className={`transition-colors duration-300 ${winner || isAnimating ? 'pointer-events-none' : 'cursor-pointer'} ${isSelected ? 'fill-amber-100 stroke-amber-400 stroke-2' : isDest ? 'fill-emerald-100 stroke-emerald-400 stroke-2' : 'fill-white stroke-slate-200'}`}
                                            onClick={() => handleTileClick(tile, i)} />
                                    );
                                })}
                                {phase === 'move_tile' && typeof selectedId === 'number' && validDests.map((dest, i) => {
                                    const { x, y } = hexToPixel(dest.q, dest.r);
                                    return (
                                        <polygon key={`guide-${i}`} points="-30,-16 0,-34 30,-16 30,16 0,34 -30,16" transform={`translate(${x}, ${y})`}
                                            className="fill-slate-100 stroke-slate-400 stroke-2 stroke-dasharray-4 opacity-60 animate-pulse cursor-pointer"
                                            onClick={() => {
                                                const newTiles = [...tiles]; newTiles[selectedId] = { q: dest.q, r: dest.r };
                                                setTiles(newTiles); setPhase('move_token'); setTurn(turn === 'red' ? 'blue' : 'red'); setSelectedId(null);
                                            }} />
                                    );
                                })}
                                {pieces.map((p) => {
                                    const { x, y } = hexToPixel(p.q, p.r);
                                    const config = PLAYERS[p.player.toUpperCase()];
                                    return (
                                        <g key={p.id} 
                                           transform={`translate(${x}, ${y})`} 
                                           className={`piece-group ${winner || isAnimating ? '' : 'piece-hit-area'}`} 
                                           onClick={() => handlePieceClick(p)}>
                                            <circle r="25" className="fill-transparent" />
                                            {/* 二重丸にしてさらにコマらしく、影をつけて立体的に */}
                                            <circle r="20" className={`${config.color} ${selectedId === p.id ? 'stroke-white stroke-[4px]' : 'stroke-black/10 stroke-1'} transition-all duration-300 shadow-xl`} />
                                            <circle r="14" className="fill-black/5 pointer-events-none" />
                                        </g>
                                    );
                                })}
                            </g>
                        </svg>
                    </div>

                    <div className="flex flex-col items-center gap-6 px-4 py-8 w-full max-w-xl">
                        <div className="bg-white rounded-2xl p-6 shadow-soft border border-slate-100 w-full">
                            <h3 className="text-sm font-bold text-slate-800 mb-4 border-b pb-2">遊び方のルール</h3>
                            <div className="text-xs text-slate-600 space-y-4 leading-relaxed">
                                <div><span className="font-bold text-rose-600 underline">勝利条件：</span>自分のコマを3つ連結させる。</div>
                                <div className="flex gap-2"><span className="bg-slate-800 text-white px-2 rounded font-bold">1</span>コマを壁や他のコマにぶつかるまで滑らせる。</div>
                                <div className="flex gap-2"><span className="bg-slate-800 text-white px-2 rounded font-bold">2</span>空いているタイルを1つ別の場所へ移動させる。</div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<NonagaGame />);
    </script>
</body>
</html>