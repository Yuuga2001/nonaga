<!DOCTYPE html>
<html lang="ja" prefix="og: http://ogp.me/ns#">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, viewport-fit=cover">

    <!-- Primary Meta Tags -->
    <title>NONAGAï¼ˆãƒãƒŠã‚¬ï¼‰- ç›¤é¢ãŒå‹•ãæ–°æ„Ÿè¦šã®æˆ¦ç•¥ãƒœãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ </title>
    <meta name="title" content="NONAGAï¼ˆãƒãƒŠã‚¬ï¼‰- ç›¤é¢ãŒå‹•ãæ–°æ„Ÿè¦šã®æˆ¦ç•¥ãƒœãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ">
    <meta name="description" content="å…­è§’å½¢ã®ç›¤é¢ã‚’æ“ã‚Šã€3ã¤ã®ã‚³ãƒã‚’ç¹‹ã’ã¦å‹åˆ©ã‚’ç›®æŒ‡ã™2äººå¯¾æˆ¦ã‚²ãƒ¼ãƒ ã€‚ã‚³ãƒã ã‘ã§ãªãç›¤é¢ã®ã‚¿ã‚¤ãƒ«è‡ªä½“ã‚’å‹•ã‹ã›ã‚‹ç‹¬ç‰¹ãªãƒ«ãƒ¼ãƒ«ã€‚5åˆ†ã§ç†è§£ã€ä¸€ç”Ÿæ¥½ã—ã‚ã‚‹å¥¥æ·±ã„æˆ¦è¡“æ€§ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã§ä»Šã™ãç„¡æ–™ãƒ—ãƒ¬ã‚¤ï¼">
    <meta name="keywords" content="NONAGA,ãƒãƒŠã‚¬,ãƒœãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ,æˆ¦ç•¥ã‚²ãƒ¼ãƒ ,å…­è§’å½¢,ãƒ˜ãƒƒã‚¯ã‚¹,2äººå¯¾æˆ¦,ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ,ãƒ–ãƒ©ã‚¦ã‚¶ã‚²ãƒ¼ãƒ ,ç„¡æ–™ã‚²ãƒ¼ãƒ ,ãƒ‘ã‚ºãƒ«ã‚²ãƒ¼ãƒ ,æ€è€ƒã‚²ãƒ¼ãƒ ,AIå¯¾æˆ¦">
    <meta name="author" content="NONAGA">
    <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    <link rel="canonical" href="https://nonaga.riverapp.jp/">

    <!-- Language & Geo Tags -->
    <meta http-equiv="content-language" content="ja">
    <meta name="geo.region" content="JP">
    <meta name="language" content="Japanese">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://nonaga.riverapp.jp/">
    <meta property="og:title" content="NONAGAï¼ˆãƒãƒŠã‚¬ï¼‰- ç›¤é¢ãŒå‹•ãæ–°æ„Ÿè¦šã®æˆ¦ç•¥ãƒœãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ">
    <meta property="og:description" content="å…­è§’å½¢ã®ç›¤é¢ã‚’æ“ã‚Šã€3ã¤ã®ã‚³ãƒã‚’ç¹‹ã’ã¦å‹åˆ©ã‚’ç›®æŒ‡ã™2äººå¯¾æˆ¦ã‚²ãƒ¼ãƒ ã€‚5åˆ†ã§ç†è§£ã€ä¸€ç”Ÿæ¥½ã—ã‚ã‚‹å¥¥æ·±ã„æˆ¦è¡“æ€§ã€‚">
    <meta property="og:image" content="https://nonaga.riverapp.jp/ogp.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:locale" content="ja_JP">
    <meta property="og:site_name" content="NONAGA">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://nonaga.riverapp.jp/">
    <meta name="twitter:title" content="NONAGAï¼ˆãƒãƒŠã‚¬ï¼‰- ç›¤é¢ãŒå‹•ãæ–°æ„Ÿè¦šã®æˆ¦ç•¥ãƒœãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ">
    <meta name="twitter:description" content="å…­è§’å½¢ã®ç›¤é¢ã‚’æ“ã‚Šã€3ã¤ã®ã‚³ãƒã‚’ç¹‹ã’ã¦å‹åˆ©ã‚’ç›®æŒ‡ã™2äººå¯¾æˆ¦ã‚²ãƒ¼ãƒ ã€‚5åˆ†ã§ç†è§£ã€ä¸€ç”Ÿæ¥½ã—ã‚ã‚‹å¥¥æ·±ã„æˆ¦è¡“æ€§ã€‚">
    <meta name="twitter:image" content="https://nonaga.riverapp.jp/ogp.png">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    <link rel="shortcut icon" href="favicon.png">

    <!-- Preconnect for CDN performance -->
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="dns-prefetch" href="https://unpkg.com">

    <!-- Theme Color -->
    <meta name="theme-color" content="#6366f1">

    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "NONAGA",
      "alternateName": "ãƒãƒŠã‚¬",
      "description": "å…­è§’å½¢ã®ç›¤é¢ã‚’æ“ã‚Šã€3ã¤ã®ã‚³ãƒã‚’ç¹‹ã’ã¦å‹åˆ©ã‚’ç›®æŒ‡ã™2äººå¯¾æˆ¦ã‚²ãƒ¼ãƒ ã€‚ã‚³ãƒã ã‘ã§ãªãç›¤é¢ã®ã‚¿ã‚¤ãƒ«è‡ªä½“ã‚’å‹•ã‹ã›ã‚‹ç‹¬ç‰¹ãªãƒ«ãƒ¼ãƒ«ãŒç‰¹å¾´ã®æˆ¦ç•¥ã‚²ãƒ¼ãƒ ã€‚",
      "url": "https://nonaga.riverapp.jp/",
      "image": {
        "@type": "ImageObject",
        "url": "https://nonaga.riverapp.jp/ogp.png",
        "width": 1200,
        "height": 630
      },
      "screenshot": "https://nonaga.riverapp.jp/ogp.png",
      "applicationCategory": "Game",
      "gamePlatform": ["Web Browser", "iOS", "Android"],
      "numberOfPlayers": {
        "@type": "QuantitativeValue",
        "minValue": 1,
        "maxValue": 2
      },
      "playMode": ["MultiPlayer", "SinglePlayer"],
      "genre": ["Strategy Game", "Board Game", "Puzzle Game"],
      "inLanguage": "ja",
      "isAccessibleForFree": true,
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "JPY",
        "availability": "https://schema.org/InStock"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "100",
        "bestRating": "5",
        "worstRating": "1"
      },
      "provider": {
        "@type": "Organization",
        "name": "NONAGA"
      },
      "datePublished": "2026-01-13",
      "interactionStatistic": {
        "@type": "InteractionCounter",
        "interactionType": "https://schema.org/PlayGameAction",
        "userInteractionCount": 100
      }
    }
    </script>

    <!-- BreadcrumbList Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "name": "ãƒ›ãƒ¼ãƒ ",
        "item": "https://nonaga.riverapp.jp/"
      }]
    }
    </script>

    <!-- WebSite Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "NONAGA",
      "url": "https://nonaga.riverapp.jp/",
      "potentialAction": {
        "@type": "SearchAction",
        "target": "https://nonaga.riverapp.jp/?q={search_term_string}",
        "query-input": "required name=search_term_string"
      }
    }
    </script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        /* ã‚¹ãƒãƒ›ã®ãƒ–ãƒ©ã‚¦ã‚¶ãƒãƒ¼å¯¾ç­– */
        body { 
            -webkit-tap-highlight-color: transparent; 
            background-color: #f8fafc; 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; 
            min-height: 100dvh; 
            overflow-y: auto; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’è¨±å¯ */
            display: flex; 
            flex-direction: column; 
        }

        #root { display: flex; flex-direction: column; min-height: 100%; flex: 1; }
        
        .game-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            transition: background-color 1s ease;
            width: 100%;
            position: relative;
        }
        
        .game-container.bg-rose { background-color: #fff1f2; }
        .game-container.bg-indigo { background-color: #eef2ff; }
        .game-container.bg-slate { background-color: #f8fafc; }
        
        .header { position: fixed; top: 0; left: 0; right: 0; padding: 0.5rem 1rem; padding-top: calc(0.5rem + env(safe-area-inset-top)); display: flex; justify-content: center; align-items: center; z-index: 10; pointer-events: none; }
        .game-title { font-size: 1.1rem; font-weight: 900; color: #1e293b; font-style: italic; text-transform: uppercase; letter-spacing: 0.3em; }

        .status-container { position: fixed; top: 3rem; left: 0; right: 0; display: flex; flex-direction: column; align-items: center; padding: 0 1rem; width: 100%; z-index: 10; pointer-events: none; }
        .status-container > * { pointer-events: auto; }

        .mode-button { padding: 0.5rem 1.5rem; background-color: #6366f1; color: white; border-radius: 9999px; font-size: 0.875rem; font-weight: 600; border: none; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 15px rgba(99, 102, 241, 0.2); margin-left: 1rem; height: 2.5rem; display: flex; align-items: center; justify-content: center; min-width: 120px; }
        .mode-button:hover { background-color: #4f46e5; }
        .mode-button.ai { background-color: #f59e0b; }
        .mode-button.ai { box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3); }
        .mode-button.ai:hover { background-color: #d97706; }
        .mode-button:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(0.3); }
        .mode-button:disabled:hover { background-color: #6366f1; transform: none; }
        .mode-button.ai:disabled:hover { background-color: #f59e0b; }

        .victory-container { display: flex; flex-direction: column; align-items: center; z-index: 50; animation: slideInUp 0.6s cubic-bezier(0.17, 0.89, 0.32, 1.49) forwards; }
        .victory-badge { padding: 0.75rem 2rem; border-radius: 9999px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); border: 4px solid white; color: white; }
        .victory-badge.red { background-color: #f43f5e; }
        .victory-badge.blue { background-color: #6366f1; }
        
        .reset-button { margin-top: 0.75rem; padding: 0.5rem 1.5rem; background-color: #1e293b; color: white; border-radius: 9999px; font-size: 0.75rem; font-weight: 700; border: none; cursor: pointer; transition: all 0.2s; }
        .reset-button:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(0.3); }
        
        .turn-indicator { background-color: rgba(255, 255, 255, 0.95); padding: 0.5rem 1.5rem; border-radius: 9999px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); border: 1px solid #f1f5f9; display: flex; align-items: center; gap: 1rem; cursor: pointer; transition: all 0.2s; }
        .turn-indicator:hover { background-color: rgba(248, 250, 252, 0.98); box-shadow: 0 6px 20px rgba(0,0,0,0.08); transform: translateY(-1px); }
        .turn-indicator.disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(0.3); pointer-events: none; }
        .turn-indicator.disabled:hover { background-color: rgba(255, 255, 255, 0.95); box-shadow: 0 4px 15px rgba(0,0,0,0.05); transform: none; }
        .player-indicator { display: flex; align-items: center; gap: 0.5rem; opacity: 0.3; transition: all 0.3s ease; }
        .player-indicator.active { opacity: 1; font-weight: 700; transform: scale(1.1); }
        .player-dot { width: 0.8rem; height: 0.8rem; border-radius: 50%; }
        .player-dot.red { background-color: #f43f5e; }
        .player-dot.blue { background-color: #6366f1; }

        .board-container {
            flex: 1;
            display: flex;
            align-items: center;
            padding-top: 0;
            justify-content: center;
            padding: 1rem 0.5rem 2rem; /* ä¸‹éƒ¨ã«ä½™ç™½ã‚’è¿½åŠ ã—ã¦å½±ãŒåˆ‡ã‚Œãªã„ã‚ˆã†ã« */
            touch-action: none; /* ã‚²ãƒ¼ãƒ ç›¤é¢ã®ã¿èª¤æ“ä½œé˜²æ­¢ */
            min-height: 0; /* flexboxã§è‡ªå‹•è¨ˆç®— */
            overflow: visible; /* å½±ãŒåˆ‡ã‚Œãªã„ã‚ˆã†ã« */
        }

        .board-svg { width: 100%; height: auto; max-height: 70vh; overflow: visible; filter: drop-shadow(0 10px 15px rgba(0,0,0,0.1)); }
        
        .tile { transition: all 0.8s ease; fill: white; stroke: #e2e8f0; stroke-width: 1px; }
        .tile.selected-origin { fill: #fee2e2; stroke: #f43f5e; stroke-width: 2px; }
        .tile.destination-hint { fill: #f0fdf4; stroke: #34d399; stroke-dasharray: 2; }
        .tile.selectable-empty { fill: white; stroke: #fbbf24; stroke-width: 2px; animation: tile-glow 2s ease-in-out infinite; }
        .tile.victory-tile { fill: #fff1f2; stroke: #fda4af; stroke-width: 4px; }
        .tile.victory-tile.blue { fill: #eef2ff; stroke: #a5b4fc; }
        .tile.faded { opacity: 0.2; }
        
        .piece-main { transition: all 0.3s ease; stroke: rgba(0,0,0,0.1); stroke-width: 1px; }
        .piece-main.red { fill: #f43f5e; }
        .piece-main.blue { fill: #6366f1; }
        .piece-main.selected {
            stroke: #fbbf24;
            stroke-width: 6px;
            filter: drop-shadow(0 0 12px #fbbf24) drop-shadow(0 0 20px #fbbf24);
            animation: selected-pulse 0.8s ease-in-out infinite;
        }
        .piece-main.victory-piece { animation: piece-pulse 1.2s ease-in-out infinite; }
        .piece-main.my-turn { stroke: #fbbf24; stroke-width: 2px; animation: tile-glow 2s ease-in-out infinite; }

        @keyframes piece-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
        @keyframes tile-glow { 0%, 100% { stroke-width: 2px; } 50% { stroke-width: 3px; } }
        @keyframes selected-pulse {
            0%, 100% {
                transform: scale(1.25);
                stroke-width: 6px;
            }
            50% {
                transform: scale(1.35);
                stroke-width: 8px;
            }
        }
        @keyframes slideInUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes confetti-fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 0; } 10% { opacity: 1; } 100% { transform: translateY(110vh) rotate(360deg); opacity: 0; } }
        @keyframes shuffle-bounce { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-8px); } }

        .shuffle-container { background-color: rgba(255, 255, 255, 0.98); padding: 1rem 2rem; border-radius: 1rem; box-shadow: 0 10px 40px rgba(0,0,0,0.15); border: 2px solid #f1f5f9; animation: slideInUp 0.4s ease-out; }
        .shuffle-text { font-size: 0.9rem; font-weight: 700; color: #64748b; margin-bottom: 0.75rem; text-align: center; }
        .shuffle-players { display: flex; gap: 1.5rem; align-items: center; }
        .shuffle-player { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; animation: shuffle-bounce 0.6s ease-in-out infinite; }
        .shuffle-player:nth-child(1) { animation-delay: 0s; }
        .shuffle-player:nth-child(2) { animation-delay: 0.15s; }
        .shuffle-avatar { width: 3rem; height: 3rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; }
        .shuffle-avatar.ai { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4); }
        .shuffle-avatar.human { background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%); box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4); }
        .shuffle-label { font-size: 0.75rem; font-weight: 600; color: #475569; }
        
        /* ãƒ«ãƒ¼ãƒ«å‘¨ã‚Šã®ã‚¹ã‚¿ã‚¤ãƒ« - ç›¤é¢ã®ä¸Šã«é‡ã­ã‚‹ */
        .rules-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 0 1rem 1.5rem;
            padding-bottom: calc(1.5rem + env(safe-area-inset-bottom));
            width: 100%;
            max-width: 32rem;
            margin: 0 auto;
            pointer-events: none; /* ç›¤é¢ã®ã‚¯ãƒªãƒƒã‚¯ã‚’é‚ªé­”ã—ãªã„ */
            z-index: 10;
        }
        .rules-card { background: white; padding: 0.6rem; border-radius: 0.75rem; border: 1px solid #f1f5f9; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05); display: flex; flex-direction: column; gap: 0.4rem; pointer-events: auto; }
        .goal-box { background: #fffbeb; padding: 0.75rem; border-radius: 0.75rem; display: flex; gap: 0.5rem; align-items: center; font-size: 0.8rem; color: #78350f; border: 1px solid #fde68a; }
        .steps-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; }
        .step-item { display: flex; gap: 0.5rem; align-items: center; color: #64748b; font-size: 0.7rem; }
        .step-number { width: 1.35rem; height: 1.35rem; border-radius: 50%; background-color: #1e293b; color: white; display: flex; align-items: center; justify-content: center; font-weight: 700; flex-shrink: 0; }
    </style>
</head>
<body itemscope itemtype="https://schema.org/WebPage">
    <!-- Skip to main content for accessibility and SEO -->
    <a href="#main-content" style="position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden;">ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¸ã‚¹ã‚­ãƒƒãƒ—</a>

    <div id="root" role="main" aria-label="NONAGA ã‚²ãƒ¼ãƒ ç›¤é¢"></div>
    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef } = React;
        const HEX_SIZE = 38;
        const DIRECTIONS = [{q:1,r:0},{q:1,r:-1},{q:0,r:-1},{q:-1,r:0},{q:-1,r:1},{q:0,r:1}];
        const coordsKey = (q, r) => `${q},${r}`;
        const INITIAL_TILES = [{q:0, r:0}, {q:1, r:0}, {q:1, r:-1}, {q:0, r:-1}, {q:-1, r:0}, {q:-1, r:1}, {q:0, r:1}, {q:2, r:0}, {q:2, r:-1}, {q:2, r:-2}, {q:1, r:-2}, {q:0, r:-2}, {q:-1, r:-1}, {q:-2, r:0}, {q:-2, r:1}, {q:-2, r:2}, {q:-1, r:2}, {q:0, r:2}, {q:1, r:1}];
        
        const INITIAL_PIECES = [
            { id: 'r1', player: 'red',  q: 2,  r: -2 },
            { id: 'b1', player: 'blue', q: 2,  r: 0  },
            { id: 'r2', player: 'red',  q: 0,  r: 2  },
            { id: 'b2', player: 'blue', q: -2, r: 2  },
            { id: 'r3', player: 'red',  q: -2, r: 0  },
            { id: 'b3', player: 'blue', q: 0,  r: -2 }
        ];

        const Confetti = ({ winner }) => {
            const dots = useMemo(() => [...Array(40)].map((_, i) => ({ id: i, left: Math.random() * 100 + '%', delay: Math.random() * 4 + 's', size: (Math.random() * 8 + 4) + 'px', color: winner === 'red' ? '#fb7185' : '#818cf8' })), [winner]);
            return (<div style={{position: 'fixed', inset: 0, pointerEvents: 'none', zIndex: 100}}>{dots.map(d => (<div key={d.id} style={{ position: 'absolute', left: d.left, width: d.size, height: d.size, backgroundColor: d.color, borderRadius: '2px', animation: `confetti-fall 4s linear infinite`, animationDelay: d.delay }} />))}</div>);
        };

        const ShuffleAnimation = () => {
            return (
                <div className="shuffle-container">
                    <div className="shuffle-text">å…ˆæ”»ã‚’æ±ºã‚ã¦ã„ã¾ã™...</div>
                    <div className="shuffle-players">
                        <div className="shuffle-player">
                            <div className="shuffle-avatar ai">ğŸ¤–</div>
                            <div className="shuffle-label">AI</div>
                        </div>
                        <div style={{fontSize: '1.5rem', color: '#cbd5e1'}}>âš¡</div>
                        <div className="shuffle-player">
                            <div className="shuffle-avatar human">ğŸ‘¤</div>
                            <div className="shuffle-label">ã‚ãªãŸ</div>
                        </div>
                    </div>
                </div>
            );
        };

        const NonagaGame = () => {
            const [tiles, setTiles] = useState(INITIAL_TILES);
            const [pieces, setPieces] = useState(INITIAL_PIECES);
            const [turn, setTurn] = useState('red');
            const [phase, setPhase] = useState('move_token');
            const [selectedId, setSelectedId] = useState(null);
            const [winner, setWinner] = useState(null);
            const [victoryLine, setVictoryLine] = useState([]);
            const [isAnimating, setIsAnimating] = useState(false);
            const [animatingPiece, setAnimatingPiece] = useState(null);
            const [animatingTile, setAnimatingTile] = useState(null);
            const [gameMode, setGameMode] = useState('ai'); // 'pvp' or 'ai'
            const [aiPlayer, setAiPlayer] = useState(() => Math.random() < 0.5 ? 'red' : 'blue'); // 'red' or 'blue'
            const [aiThinking, setAiThinking] = useState(false);
            const [isShuffling, setIsShuffling] = useState(true); // åˆå›ã¯ã‚·ãƒ£ãƒƒãƒ•ãƒ«è¡¨ç¤º
            const animationFrameRef = useRef(null);
            const shuffleTimeoutRef = useRef(null);

            const resetGame = () => {
                // ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
                if (shuffleTimeoutRef.current) {
                    clearTimeout(shuffleTimeoutRef.current);
                }

                setTiles(INITIAL_TILES);
                setPieces(INITIAL_PIECES);
                setTurn('red');
                setPhase('move_token');
                setSelectedId(null);
                setWinner(null);
                setVictoryLine([]);
                setIsAnimating(false);
                setAnimatingPiece(null);
                setAnimatingTile(null);
                setAiThinking(false);

                // AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€å…ˆæ”»å¾Œæ”»ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«å†è¨­å®š + ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (gameMode === 'ai') {
                    setIsShuffling(true);
                    const newAiPlayer = Math.random() < 0.5 ? 'red' : 'blue';
                    shuffleTimeoutRef.current = setTimeout(() => {
                        setAiPlayer(newAiPlayer);
                        setIsShuffling(false);
                    }, 1200);
                }
            };

            const switchMode = () => {
                // ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
                if (shuffleTimeoutRef.current) {
                    clearTimeout(shuffleTimeoutRef.current);
                }

                const newMode = gameMode === 'pvp' ? 'ai' : 'pvp';
                setGameMode(newMode);

                setTiles(INITIAL_TILES);
                setPieces(INITIAL_PIECES);
                setTurn('red');
                setPhase('move_token');
                setSelectedId(null);
                setWinner(null);
                setVictoryLine([]);
                setIsAnimating(false);
                setAnimatingPiece(null);
                setAnimatingTile(null);
                setAiThinking(false);

                if (newMode === 'ai') {
                    setIsShuffling(true);
                    const newAiPlayer = Math.random() < 0.5 ? 'red' : 'blue';
                    shuffleTimeoutRef.current = setTimeout(() => {
                        setAiPlayer(newAiPlayer);
                        setIsShuffling(false);
                    }, 1200);
                } else {
                    setAiPlayer(null);
                    setIsShuffling(false);
                }
            };

            const tileMap = useMemo(() => new Set(tiles.map(t => coordsKey(t.q, t.r))), [tiles]);
            const pieceMap = useMemo(() => { const map = new Map(); pieces.forEach(p => map.set(coordsKey(p.q, p.r), p)); return map; }, [pieces]);
            const hexToPixel = (q, r) => ({ x: HEX_SIZE * (3/2 * q), y: HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r) });
            
            const viewBounds = useMemo(() => {
                const padding = 60;
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                tiles.forEach(t => {
                    const { x, y } = hexToPixel(t.q, t.r);
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                });
                return { x: minX - padding, y: minY - padding, w: (maxX - minX) + padding * 2, h: (maxY - minY) + padding * 2 };
            }, [tiles]);

            const getVictoryCoords = (currentPieces, player) => {
                const p = currentPieces.filter(cp => cp.player === player);
                const isAdj = (a, b) => DIRECTIONS.some(d => a.q + d.q === b.q && a.r + d.r === b.r);
                const c01 = isAdj(p[0], p[1]), c12 = isAdj(p[1], p[2]), c20 = isAdj(p[2], p[0]);
                if ((c01 ? 1:0) + (c12 ? 1:0) + (c20 ? 1:0) >= 2) return p.map(item => coordsKey(item.q, item.r));
                return null;
            };

            const animatePieceMove = (pieceId, fromQ, fromR, toQ, toR) => {
                const startTime = performance.now();
                const fromPos = hexToPixel(fromQ, fromR);
                const toPos = hexToPixel(toQ, toR);
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / 800, 1);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    setAnimatingPiece({ id: pieceId, x: fromPos.x + (toPos.x - fromPos.x) * eased, y: fromPos.y + (toPos.y - fromPos.y) * eased });
                    if (progress < 1) animationFrameRef.current = requestAnimationFrame(animate);
                    else {
                        setAnimatingPiece(null); setIsAnimating(false);
                        const nextPieces = pieces.map(p => p.id === pieceId ? { ...p, q: toQ, r: toR } : p);
                        setPieces(nextPieces);
                        const winCoords = getVictoryCoords(nextPieces, turn);
                        if (winCoords) { setWinner(turn); setVictoryLine(winCoords); setPhase('ended'); }
                        else { setPhase('move_tile'); setSelectedId(null); }
                    }
                };
                animationFrameRef.current = requestAnimationFrame(animate);
            };

            const animateTileMove = (tileIndex, fromQ, fromR, toQ, toR) => {
                const startTime = performance.now();
                const fromPos = hexToPixel(fromQ, fromR);
                const toPos = hexToPixel(toQ, toR);
                const isAiTurn = gameMode === 'ai' && turn === aiPlayer;
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / 800, 1);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    setAnimatingTile({ index: tileIndex, x: fromPos.x + (toPos.x - fromPos.x) * eased, y: fromPos.y + (toPos.y - fromPos.y) * eased });
                    if (progress < 1) animationFrameRef.current = requestAnimationFrame(animate);
                    else {
                        setAnimatingTile(null);
                        const nt = [...tiles]; nt[tileIndex] = { q: toQ, r: toR };
                        setTiles(nt); setPhase('move_token'); setSelectedId(null);

                        // AIã®ã‚¿ãƒ¼ãƒ³ã®å ´åˆã¯0.5ç§’å¾…ã£ã¦ã‹ã‚‰é †ç•ªã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
                        if (isAiTurn) {
                            setTimeout(() => {
                                setIsAnimating(false);
                                setTurn(turn === 'red' ? 'blue' : 'red');
                            }, 500);
                        } else {
                            setIsAnimating(false);
                            setTurn(turn === 'red' ? 'blue' : 'red');
                        }
                    }
                };
                animationFrameRef.current = requestAnimationFrame(animate);
            };

            const handlePieceClick = (piece) => { if (winner || phase !== 'move_token' || piece.player !== turn || isAnimating || aiThinking || isShuffling || (gameMode === 'ai' && turn === aiPlayer)) return; setSelectedId(selectedId === piece.id ? null : piece.id); };
            const handleTileClick = (tile, index) => {
                if (winner || isAnimating || aiThinking || isShuffling || (gameMode === 'ai' && turn === aiPlayer)) return;
                if (phase === 'move_token' && typeof selectedId === 'string') {
                    const piece = pieces.find(p => p.id === selectedId);
                    const moves = DIRECTIONS.map(dir => {
                        let curQ = piece.q, curR = piece.r, lastValid = null;
                        while (true) {
                            const nQ = curQ + dir.q, nR = curR + dir.r;
                            if (!tileMap.has(coordsKey(nQ, nR)) || pieceMap.has(coordsKey(nQ, nR))) break;
                            lastValid = { q: nQ, r: nR }; curQ = nQ; curR = nR;
                        }
                        return lastValid;
                    }).filter(Boolean);
                    if (moves.some(m => m.q === tile.q && m.r === tile.r)) { setIsAnimating(true); animatePieceMove(selectedId, piece.q, piece.r, tile.q, tile.r); }
                } else if (phase === 'move_tile' && !pieceMap.has(coordsKey(tile.q, tile.r))) {
                    const temp = tiles.filter((_, i) => i !== index);
                    const q = [temp[0]], vis = new Set([coordsKey(temp[0].q, temp[0].r)]);
                    while(q.length > 0) {
                        const cur = q.shift();
                        DIRECTIONS.forEach(d => {
                            const k = coordsKey(cur.q+d.q, cur.r+d.r);
                            if(temp.some(t => coordsKey(t.q, t.r) === k) && !vis.has(k)) { vis.add(k); q.push({q:cur.q+d.q, r:cur.r+d.r}); }
                        });
                    }
                    if (vis.size === temp.length) setSelectedId(index);
                    else alert("ç›¤é¢ã‚’åˆ†æ–­ã§ãã¾ã›ã‚“");
                }
            };

            const makeAIMove = () => {
                if (aiThinking || isAnimating || winner) return;
                setAiThinking(true);

                setTimeout(() => {
                    if (phase === 'move_token') {
                        const myPieces = pieces.filter(p => p.player === turn);
                        if (myPieces.length === 0) {
                            setAiThinking(false);
                            return;
                        }

                        // å…¨ã‚³ãƒã®å…¨ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©•ä¾¡
                        let bestMove = null;
                        let bestScore = -Infinity;

                        myPieces.forEach(piece => {
                            DIRECTIONS.forEach(dir => {
                                let cq = piece.q, cr = piece.r;
                                while (true) {
                                    const nq = cq + dir.q, nr = cr + dir.r;
                                    if (!tileMap.has(coordsKey(nq, nr))) break;
                                    if (pieceMap.has(coordsKey(nq, nr))) break;
                                    cq = nq; cr = nr;
                                }
                                if (cq === piece.q && cr === piece.r) return;

                                const testPieces = pieces.map(p => p.id === piece.id ? { ...p, q: cq, r: cr } : p);
                                const myTestPieces = testPieces.filter(p => p.player === turn);
                                const enemyPieces = testPieces.filter(p => p.player !== turn);

                                let score = 0;

                                // ã€æœ€å„ªå…ˆã€‘å‹åˆ©åˆ¤å®šï¼ˆå³å‹ã¡ãªã‚‰10000ç‚¹ï¼‰
                                let adjacentPairs = 0;
                                for (let i = 0; i < myTestPieces.length; i++) {
                                    for (let j = i + 1; j < myTestPieces.length; j++) {
                                        const p1 = myTestPieces[i], p2 = myTestPieces[j];
                                        if (DIRECTIONS.some(d => p1.q + d.q === p2.q && p1.r + d.r === p2.r)) {
                                            adjacentPairs++;
                                        }
                                    }
                                }
                                if (adjacentPairs >= 2) {
                                    score = 10000;
                                } else {
                                    // éš£æ¥ãƒšã‚¢æ•°ï¼ˆå¤šã„ã»ã©å‹åˆ©ã«è¿‘ã„ï¼‰
                                    score += adjacentPairs * 500;

                                    // ã‚³ãƒé–“ã®æœ€å°è·é›¢ï¼ˆè¿‘ã„ã»ã©è‰¯ã„ï¼‰
                                    let minDist = Infinity;
                                    for (let i = 0; i < myTestPieces.length; i++) {
                                        for (let j = i + 1; j < myTestPieces.length; j++) {
                                            const p1 = myTestPieces[i], p2 = myTestPieces[j];
                                            const dist = Math.abs(p1.q - p2.q) + Math.abs(p1.r - p2.r);
                                            minDist = Math.min(minDist, dist);
                                        }
                                    }
                                    score -= minDist * 30;

                                    // ã‚³ãƒã®å¯†é›†åº¦ï¼ˆ3ã¤ã®ã‚³ãƒã®é‡å¿ƒã‹ã‚‰ã®è·é›¢ï¼‰
                                    const centerQ = myTestPieces.reduce((sum, p) => sum + p.q, 0) / 3;
                                    const centerR = myTestPieces.reduce((sum, p) => sum + p.r, 0) / 3;
                                    const compactness = myTestPieces.reduce((sum, p) => {
                                        return sum + Math.abs(p.q - centerQ) + Math.abs(p.r - centerR);
                                    }, 0);
                                    score -= compactness * 20;

                                    // ã€é˜²å¾¡ã€‘ç›¸æ‰‹ã®å‹åˆ©ã‚’é˜»æ­¢
                                    let enemyAdjacentPairs = 0;
                                    for (let i = 0; i < enemyPieces.length; i++) {
                                        for (let j = i + 1; j < enemyPieces.length; j++) {
                                            const p1 = enemyPieces[i], p2 = enemyPieces[j];
                                            if (DIRECTIONS.some(d => p1.q + d.q === p2.q && p1.r + d.r === p2.r)) {
                                                enemyAdjacentPairs++;
                                            }
                                        }
                                    }
                                    score -= enemyAdjacentPairs * 200;

                                    // ç›¤é¢ä¸­å¤®å¯„ã‚Šã‚’å„ªé‡
                                    const distToCenter = Math.abs(cq) + Math.abs(cr);
                                    score -= distToCenter * 5;
                                }

                                if (score > bestScore) {
                                    bestScore = score;
                                    bestMove = { piece, dest: { q: cq, r: cr } };
                                }
                            });
                        });

                        if (bestMove) {
                            setIsAnimating(true);
                            animatePieceMove(bestMove.piece.id, bestMove.piece.q, bestMove.piece.r, bestMove.dest.q, bestMove.dest.r);
                        }
                    } else if (phase === 'move_tile') {
                        const myPieces = pieces.filter(p => p.player === turn);
                        const emptyTiles = tiles.map((t, i) => ({ tile: t, index: i }))
                            .filter(({ tile }) => !pieceMap.has(coordsKey(tile.q, tile.r)));

                        if (emptyTiles.length === 0) {
                            setAiThinking(false);
                            return;
                        }

                        let bestMove = null;
                        let bestScore = -Infinity;

                        emptyTiles.forEach(({ tile: selectedTile, index: selectedIndex }) => {
                            const rem = tiles.filter((_, i) => i !== selectedIndex);
                            const candidates = new Map();

                            rem.forEach(t => DIRECTIONS.forEach(d => {
                                const nQ = t.q + d.q, nR = t.r + d.r, k = coordsKey(nQ, nR);
                                if (rem.some(rt => rt.q === nQ && rt.r === nR) || coordsKey(selectedTile.q, selectedTile.r) === k) return;
                                const data = candidates.get(k) || { q: nQ, r: nR, c: 0 };
                                data.c++;
                                candidates.set(k, data);
                            }));

                            candidates.forEach((dest, k) => {
                                if (dest.c < 2) return;

                                // æ¥ç¶šæ€§ãƒã‚§ãƒƒã‚¯: ã‚¿ã‚¤ãƒ«ç§»å‹•å¾Œã‚‚ç›¤é¢ãŒç¹‹ãŒã£ã¦ã„ã‚‹ã‹ç¢ºèª
                                const tempTiles = rem.map(t => ({ q: t.q, r: t.r }));
                                tempTiles.push({ q: dest.q, r: dest.r });
                                const queue = [tempTiles[0]];
                                const visited = new Set([coordsKey(tempTiles[0].q, tempTiles[0].r)]);
                                while (queue.length > 0) {
                                    const cur = queue.shift();
                                    DIRECTIONS.forEach(d => {
                                        const k2 = coordsKey(cur.q + d.q, cur.r + d.r);
                                        if (tempTiles.some(t => coordsKey(t.q, t.r) === k2) && !visited.has(k2)) {
                                            visited.add(k2);
                                            queue.push({ q: cur.q + d.q, r: cur.r + d.r });
                                        }
                                    });
                                }
                                if (visited.size !== tempTiles.length) return; // ç›¤é¢ãŒåˆ†æ–­ã•ã‚Œã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—

                                let score = 0;
                                const enemyPieces = pieces.filter(p => p.player !== turn);

                                // ã€æœ€å„ªå…ˆã€‘ç›¸æ‰‹ã®å‹åˆ©ã‚’é˜»æ­¢ã™ã‚‹
                                // ã‚¿ã‚¤ãƒ«ç§»å‹•å¾Œã®ç›¤é¢ã§ç›¸æ‰‹ãŒæ¬¡ã®ã‚¿ãƒ¼ãƒ³ã«å‹ã¦ã‚‹ã‹åˆ¤å®š
                                const newTiles = [...rem, { q: dest.q, r: dest.r }];
                                const newTileMap = new Set(newTiles.map(t => coordsKey(t.q, t.r)));

                                // ç›¸æ‰‹ã®å„ã‚³ãƒã«ã¤ã„ã¦ã€å…¨æ–¹å‘ã«ã‚¹ãƒ©ã‚¤ãƒ‰ã•ã›ã¦å‹åˆ©åˆ¤å®š
                                let enemyCanWinNextTurn = false;
                                for (const enemyPiece of enemyPieces) {
                                    for (const dir of DIRECTIONS) {
                                        let eq = enemyPiece.q, er = enemyPiece.r;
                                        while (true) {
                                            const nQ = eq + dir.q, nR = er + dir.r;
                                            if (!newTileMap.has(coordsKey(nQ, nR))) break;
                                            if (pieces.some(p => p.q === nQ && p.r === nR && p.id !== enemyPiece.id)) break;
                                            eq = nQ; er = nR;
                                        }
                                        if (eq === enemyPiece.q && er === enemyPiece.r) continue;

                                        // ã“ã®ç§»å‹•å¾Œã«ç›¸æ‰‹ãŒå‹ã¤ã‹åˆ¤å®š
                                        const testEnemyPieces = enemyPieces.map(p =>
                                            p.id === enemyPiece.id ? { ...p, q: eq, r: er } : p
                                        );
                                        let adjacentPairs = 0;
                                        for (let i = 0; i < testEnemyPieces.length; i++) {
                                            for (let j = i + 1; j < testEnemyPieces.length; j++) {
                                                const p1 = testEnemyPieces[i], p2 = testEnemyPieces[j];
                                                if (DIRECTIONS.some(d => p1.q + d.q === p2.q && p1.r + d.r === p2.r)) {
                                                    adjacentPairs++;
                                                }
                                            }
                                        }
                                        if (adjacentPairs >= 2) {
                                            enemyCanWinNextTurn = true;
                                            break;
                                        }
                                    }
                                    if (enemyCanWinNextTurn) break;
                                }

                                // ç›¸æ‰‹ãŒæ¬¡ã®ã‚¿ãƒ¼ãƒ³ã§å‹ã¦ã‚‹ãªã‚‰ã€ã“ã®ã‚¿ã‚¤ãƒ«ç§»å‹•ã§é˜»æ­¢ã§ãã‚‹å ´åˆã¯è¶…é«˜å¾—ç‚¹
                                const enemyPieceTiles = enemyPieces.map(p => coordsKey(p.q, p.r));
                                const isEnemyPieceOnSelectedTile = enemyPieceTiles.includes(coordsKey(selectedTile.q, selectedTile.r));

                                if (enemyCanWinNextTurn && isEnemyPieceOnSelectedTile) {
                                    // ç›¸æ‰‹ã®ã‚³ãƒãŒä¹—ã£ã¦ã„ã‚‹ã‚¿ã‚¤ãƒ«ã‚’å‹•ã‹ã™ã“ã¨ã§å‹åˆ©ã‚’é˜»æ­¢
                                    score += 15000; // æœ€å„ªå…ˆ
                                } else if (enemyCanWinNextTurn) {
                                    // ç›¸æ‰‹ãŒå‹ã¦ã‚‹çŠ¶æ³ã ãŒã€ã“ã®ã‚¿ã‚¤ãƒ«ç§»å‹•ã§ã¯é˜»æ­¢ã§ããªã„
                                    score -= 5000; // ãƒšãƒŠãƒ«ãƒ†ã‚£
                                }

                                // ç›¸æ‰‹ã®éš£æ¥ãƒšã‚¢æ•°ã‚’è¨ˆç®—ï¼ˆé˜²å¾¡çš„è©•ä¾¡ï¼‰
                                let enemyAdjacentPairs = 0;
                                for (let i = 0; i < enemyPieces.length; i++) {
                                    for (let j = i + 1; j < enemyPieces.length; j++) {
                                        const p1 = enemyPieces[i], p2 = enemyPieces[j];
                                        if (DIRECTIONS.some(d => p1.q + d.q === p2.q && p1.r + d.r === p2.r)) {
                                            enemyAdjacentPairs++;
                                        }
                                    }
                                }

                                // ç›¸æ‰‹ãŒä¹—ã£ã¦ã„ã‚‹ã‚¿ã‚¤ãƒ«ã‚’å‹•ã‹ã™å ´åˆã®è©•ä¾¡
                                if (isEnemyPieceOnSelectedTile) {
                                    const selectedEnemyPiece = enemyPieces.find(p => p.q === selectedTile.q && p.r === selectedTile.r);
                                    if (selectedEnemyPiece) {
                                        const otherEnemyPieces = enemyPieces.filter(p => p.id !== selectedEnemyPiece.id);
                                        const avgDistBefore = otherEnemyPieces.reduce((sum, p) => {
                                            return sum + Math.abs(selectedTile.q - p.q) + Math.abs(selectedTile.r - p.r);
                                        }, 0) / otherEnemyPieces.length;
                                        const avgDistAfter = otherEnemyPieces.reduce((sum, p) => {
                                            return sum + Math.abs(dest.q - p.q) + Math.abs(dest.r - p.r);
                                        }, 0) / otherEnemyPieces.length;

                                        // ç›¸æ‰‹ã‚’é ã–ã‘ã‚‹ã»ã©é«˜å¾—ç‚¹
                                        const distImprovement = avgDistAfter - avgDistBefore;
                                        score += distImprovement * 100;

                                        // ç›¸æ‰‹ãŒæ—¢ã«éš£æ¥ãƒšã‚¢ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã¯æ›´ã«å„ªå…ˆ
                                        if (enemyAdjacentPairs >= 1) {
                                            score += distImprovement * 200;
                                        }
                                    }
                                }

                                // è‡ªã‚³ãƒãŒä¹—ã£ã¦ã„ã‚‹ã‚¿ã‚¤ãƒ«ã‚’ç§»å‹•ã™ã‚‹å ´åˆ
                                const myPieceTiles = myPieces.map(p => coordsKey(p.q, p.r));
                                const isMyPieceOnSelectedTile = myPieceTiles.includes(coordsKey(selectedTile.q, selectedTile.r));

                                if (isMyPieceOnSelectedTile) {
                                    const selectedPiece = myPieces.find(p => p.q === selectedTile.q && p.r === selectedTile.r);
                                    if (selectedPiece) {
                                        const otherPieces = myPieces.filter(p => p.id !== selectedPiece.id);
                                        const avgDist = otherPieces.reduce((sum, p) => {
                                            return sum + Math.abs(dest.q - p.q) + Math.abs(dest.r - p.r);
                                        }, 0) / otherPieces.length;
                                        score -= avgDist * 50;
                                    }
                                } else {
                                    // ç©ºã‚¿ã‚¤ãƒ«ã®å ´åˆã€è‡ªã‚³ãƒé–“ã®è·é›¢ã‚’è©•ä¾¡
                                    let totalDist = 0;
                                    for (let i = 0; i < myPieces.length; i++) {
                                        for (let j = i + 1; j < myPieces.length; j++) {
                                            const p1 = myPieces[i], p2 = myPieces[j];
                                            const dist = Math.abs(p1.q - p2.q) + Math.abs(p1.r - p2.r);
                                            totalDist += dist;
                                        }
                                    }
                                    score -= totalDist * 10;
                                }

                                // ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ï¼ˆäºˆæ¸¬ä¸èƒ½æ€§ï¼‰- ãŸã ã—å½±éŸ¿ã‚’å°ã•ã
                                score += Math.random() * 3;

                                if (score > bestScore) {
                                    bestScore = score;
                                    bestMove = { selectedIndex, dest };
                                }
                            });
                        });

                        if (bestMove) {
                            const tile = tiles[bestMove.selectedIndex];
                            setIsAnimating(true);
                            animateTileMove(bestMove.selectedIndex, tile.q, tile.r, bestMove.dest.q, bestMove.dest.r);
                        }
                    }
                    setAiThinking(false);
                }, 800);
            };

            // åˆå›ãƒã‚¦ãƒ³ãƒˆæ™‚ã®ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            useEffect(() => {
                if (gameMode === 'ai' && isShuffling) {
                    shuffleTimeoutRef.current = setTimeout(() => {
                        setIsShuffling(false);
                    }, 1200);
                }
                return () => {
                    if (shuffleTimeoutRef.current) {
                        clearTimeout(shuffleTimeoutRef.current);
                    }
                };
            }, []);

            useEffect(() => {
                if (gameMode === 'ai' && turn === aiPlayer && !winner && !isAnimating && !aiThinking && !isShuffling) {
                    makeAIMove();
                }
            }, [turn, phase, gameMode, aiPlayer, winner, isAnimating, aiThinking, isShuffling]);

            const validDests = useMemo(() => {
                if (winner || isAnimating) return [];
                if (phase === 'move_token' && typeof selectedId === 'string') {
                    const piece = pieces.find(p => p.id === selectedId);
                    return DIRECTIONS.map(dir => {
                        let curQ = piece.q, curR = piece.r, lastValid = null;
                        while (true) {
                            const nQ = curQ + dir.q, nR = curR + dir.r;
                            if (!tileMap.has(coordsKey(nQ, nR)) || pieceMap.has(coordsKey(nQ, nR))) break;
                            lastValid = { q: nQ, r: nR }; curQ = nQ; curR = nR;
                        }
                        return lastValid;
                    }).filter(Boolean);
                }
                if (phase === 'move_tile' && typeof selectedId === 'number') {
                    const cands = new Map(), rem = tiles.filter((_, i) => i !== selectedId);
                    rem.forEach(t => DIRECTIONS.forEach(d => {
                        const nQ = t.q+d.q, nR = t.r+d.r, k = coordsKey(nQ, nR);
                        if (rem.some(rt => rt.q===nQ && rt.r===nR) || coordsKey(tiles[selectedId].q, tiles[selectedId].r) === k) return;
                        const data = cands.get(k) || { q:nQ, r:nR, c:0 };
                        data.c++; cands.set(k, data);
                    }));
                    return Array.from(cands.values()).filter(c => c.c >= 2);
                }
                return [];
            }, [selectedId, phase, tiles, pieces, tileMap, pieceMap, winner, isAnimating]);

            return (
                <div id="main-content" className={`game-container ${winner === 'red' ? 'bg-rose' : winner === 'blue' ? 'bg-indigo' : 'bg-slate'}`}>
                    {winner && <Confetti winner={winner} />}
                    <header className="header" role="banner">
                        <h1 className="game-title">Nonaga</h1>
                    </header>

                    <div className="status-container">
                        {isShuffling && gameMode === 'ai' ? (
                            <ShuffleAnimation />
                        ) : winner ? (
                            <div className="victory-container">
                                <div className={`victory-badge ${winner}`}><span style={{fontSize:20, fontWeight:900}}>
                                    {gameMode === 'ai'
                                        ? (winner === aiPlayer ? 'AIã®å‹ã¡!' : 'ã‚ãªãŸã®å‹ã¡!')
                                        : (winner === 'red' ? 'èµ¤ã®å‹ã¡!' : 'é’ã®å‹ã¡!')
                                    }
                                </span></div>
                                <button onClick={resetGame} className="reset-button" disabled={isAnimating || aiThinking}>ã‚‚ã†ä¸€åº¦ã‚ãã¶</button>
                            </div>
                        ) : (
                            <div style={{display:'flex', flexDirection:'column', alignItems:'center'}}>
                                <div style={{display:'flex', alignItems:'center'}}>
                                    <div className={`turn-indicator ${(isAnimating || aiThinking) ? 'disabled' : ''}`} onClick={(isAnimating || aiThinking) ? undefined : resetGame}>
                                        <div className={`player-indicator ${turn === 'red' ? 'active' : ''}`}>
                                            <div className="player-dot red" />
                                            {gameMode === 'ai' ? (aiPlayer === 'red' ? 'AI' : 'ã‚ãªãŸ') : 'èµ¤'}
                                        </div>
                                        <div style={{width:1, height:12, background:'#e2e8f0'}} />
                                        <div className={`player-indicator ${turn === 'blue' ? 'active' : ''}`}>
                                            <div className="player-dot blue" />
                                            {gameMode === 'ai' ? (aiPlayer === 'blue' ? 'AI' : 'ã‚ãªãŸ') : 'é’'}
                                        </div>
                                    </div>
                                    <button onClick={switchMode} className={`mode-button ${gameMode === 'ai' ? 'ai' : ''}`} disabled={isAnimating || aiThinking}>
                                        {gameMode === 'pvp' ? 'ãµãŸã‚Šã§å¯¾æˆ¦' : 'AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰'}
                                    </button>
                                </div>
                                <div style={{fontSize:11, fontWeight:800, color:'#94a3b8', marginTop:10, textTransform:'uppercase', letterSpacing: '0.1em'}}>
                                    {aiThinking ? "ğŸ¤– AIæ€è€ƒä¸­..." : (phase === 'move_token' ? "1. ã‚³ãƒã‚’æ»‘ã‚‰ã›ã‚‹" : "2. ã‚¿ã‚¤ãƒ«ã‚’å‹•ã‹ã™")}
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="board-container" role="application" aria-label="NONAGA ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰">
                        <svg viewBox={`${viewBounds.x} ${viewBounds.y} ${viewBounds.w} ${viewBounds.h}`} className="board-svg" role="img" aria-label="å…­è§’å½¢ã‚¿ã‚¤ãƒ«ã¨ã‚³ãƒã®ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰">
                            <g>
                                {tiles.map((tile, i) => {
                                    const pos = (animatingTile && animatingTile.index === i) ? { x: animatingTile.x, y: animatingTile.y } : hexToPixel(tile.q, tile.r);
                                    const key = coordsKey(tile.q, tile.r);
                                    const isV = victoryLine.includes(key);
                                    const isSelected = phase === 'move_tile' && selectedId === i;
                                    const isDestHint = phase === 'move_token' && validDests.some(d => d.q === tile.q && d.r === tile.r);
                                    const isSelectableEmpty = !winner && phase === 'move_tile' && !pieceMap.has(key) && !isAnimating;
                                    return (
                                        <polygon key={`tile-${i}`} points="-34,-19 0,-38 34,-19 34,19 0,38 -34,19" transform={`translate(${pos.x}, ${pos.y})`}
                                            className={`tile ${isV ? `victory-tile ${winner}` : isSelected ? 'selected-origin' : isDestHint ? 'destination-hint' : isSelectableEmpty ? 'selectable-empty' : ''} ${winner && !isV ? 'faded' : ''}`}
                                            onClick={() => handleTileClick(tile, i)} />
                                    );
                                })}
                                {phase === 'move_tile' && typeof selectedId === 'number' && validDests.map((dest, i) => {
                                    const { x, y } = hexToPixel(dest.q, dest.r);
                                    return (
                                        <polygon key={`guide-${i}`} points="-30,-16 0,-34 30,-16 30,16 0,34 -30,16" transform={`translate(${x}, ${y})`}
                                            style={{fill:'#f0fdf4', stroke:'#34d399', strokeWidth:2, strokeDasharray:4, opacity:0.8, cursor:'pointer'}}
                                            onClick={() => {
                                                setIsAnimating(true);
                                                animateTileMove(selectedId, tiles[selectedId].q, tiles[selectedId].r, dest.q, dest.r);
                                            }} />
                                    );
                                })}
                                {pieces.map((p) => {
                                    const isV = victoryLine.includes(coordsKey(p.q, p.r));
                                    const pos = (animatingPiece && animatingPiece.id === p.id) ? { x: animatingPiece.x, y: animatingPiece.y } : hexToPixel(p.q, p.r);
                                    const isMyTurn = !winner && p.player === turn && phase === 'move_token';
                                    return (
                                        <g key={p.id} transform={`translate(${pos.x}, ${pos.y})`} style={{cursor: 'pointer'}} onClick={() => handlePieceClick(p)}>
                                            <circle r="30" fill="transparent" />
                                            <circle r="20" className={`piece-main ${p.player} ${selectedId === p.id ? 'selected' : ''} ${isV ? 'victory-piece' : ''} ${isMyTurn ? 'my-turn' : ''}`} style={{opacity: (winner && !isV) ? 0.2 : 1}} />
                                            <circle r="14" fill="rgba(0,0,0,0.05)" style={{pointerEvents:'none', opacity: (winner && !isV) ? 0 : 1}} />
                                        </g>
                                    );
                                })}
                            </g>
                        </svg>
                    </div>

                    <aside className="rules-container" role="complementary" aria-label="ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ«">
                        <div className="rules-card">
                            <div className="goal-box">
                                <span style={{fontSize:16}}>ğŸ†</span>
                                <p>è‡ªåˆ†ã®ã‚³ãƒã‚’ <strong>3ã¤é€£çµ</strong> ã•ã›ã‚Œã°å‹ã¡!</p>
                            </div>
                            <div className="steps-grid">
                                <div className="step-item">
                                    <span className="step-number">1</span>
                                    <p>ç«¯ã¾ã§ã‚³ãƒã‚’æ»‘ã‚‰ã›ã‚‹</p>
                                </div>
                                <div className="step-item">
                                    <span className="step-number">2</span>
                                    <p>ç©ºãã‚¿ã‚¤ãƒ«ã‚’ç§»å‹•ã™ã‚‹</p>
                                </div>
                            </div>
                        </div>
                    </aside>

                    {/* SEOç”¨ã®éè¡¨ç¤ºã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */}
                    <div style={{position: 'absolute', left: '-10000px', width: '1px', height: '1px', overflow: 'hidden'}}>
                        <h2>NONAGAã¨ã¯</h2>
                        <p>NONAGAã¯ã€å…­è§’å½¢ï¼ˆãƒ˜ãƒƒã‚¯ã‚¹ï¼‰ã®ç›¤é¢ã‚’ä½¿ã£ãŸé©æ–°çš„ãª2äººå¯¾æˆ¦ãƒœãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ã§ã™ã€‚ã‚³ãƒã‚’å‹•ã‹ã™ã ã‘ã§ãªãã€ç›¤é¢ã®ã‚¿ã‚¤ãƒ«è‡ªä½“ã‚‚å‹•ã‹ã›ã‚‹ç‹¬ç‰¹ã®ãƒ«ãƒ¼ãƒ«ãŒç‰¹å¾´ã§ã™ã€‚</p>
                        <h3>ã‚²ãƒ¼ãƒ ã®ç‰¹å¾´</h3>
                        <ul>
                            <li>ãƒ–ãƒ©ã‚¦ã‚¶ã§ä»Šã™ãç„¡æ–™ãƒ—ãƒ¬ã‚¤å¯èƒ½</li>
                            <li>AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰æ­è¼‰ - ä¸€äººã§ã‚‚æ¥½ã—ã‚ã‚‹</li>
                            <li>2äººå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰ - å‹é”ã‚„å®¶æ—ã¨å¯¾æˆ¦</li>
                            <li>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆãƒ»PCã«å¯¾å¿œ</li>
                            <li>ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ«ãƒ¼ãƒ«ã§å¥¥æ·±ã„æˆ¦è¡“æ€§</li>
                        </ul>
                        <h3>éŠã³æ–¹</h3>
                        <p>å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯3ã¤ã®ã‚³ãƒã‚’æŒã¡ã€ãã‚Œã‚‰ã‚’é€£çµã•ã›ã‚‹ã“ã¨ã§å‹åˆ©ã—ã¾ã™ã€‚1ã‚¿ãƒ¼ãƒ³ã¯2ã¤ã®ãƒ•ã‚§ãƒ¼ã‚ºã‹ã‚‰æ§‹æˆã•ã‚Œã¾ã™ï¼š</p>
                        <ol>
                            <li>ã‚³ãƒã‚’é¸ã‚“ã§ç«¯ã¾ã§æ»‘ã‚‰ã›ã‚‹</li>
                            <li>ç©ºã„ã¦ã„ã‚‹ã‚¿ã‚¤ãƒ«ã‚’åˆ¥ã®ä½ç½®ã¸ç§»å‹•ã™ã‚‹</li>
                        </ol>
                        <h3>å‹åˆ©æ¡ä»¶</h3>
                        <p>è‡ªåˆ†ã®3ã¤ã®ã‚³ãƒã™ã¹ã¦ãŒéš£æ¥ã—ãŸçŠ¶æ…‹ï¼ˆç·šçŠ¶ã€ä¸‰è§’å½¢ã€Vå­—ãªã©ï¼‰ã‚’ä½œã‚‹ã¨å‹åˆ©ã§ã™ã€‚</p>
                        <h3>æˆ¦ç•¥ã®ãƒã‚¤ãƒ³ãƒˆ</h3>
                        <p>ã‚³ãƒã®ç§»å‹•ã ã‘ã§ãªãã€ã‚¿ã‚¤ãƒ«ã®é…ç½®ã‚’å¤‰ãˆã‚‹ã“ã¨ã§ç›¤é¢å…¨ä½“ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã§ãã¾ã™ã€‚ç›¸æ‰‹ã®ã‚³ãƒã‚’åˆ†æ–­ã—ãŸã‚Šã€è‡ªåˆ†ã®ã‚³ãƒã‚’è¿‘ã¥ã‘ãŸã‚Šã™ã‚‹æˆ¦ç•¥çš„ãªæ€è€ƒãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚</p>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<NonagaGame />);
    </script>
</body>
</html>